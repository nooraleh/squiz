using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QNALibrary.mappings.CPP
{
    public class CPP20CompleteGuide : QNABase
    {
        public CPP20CompleteGuide()
        : base(title: "C++20 Complete Guide by Nicolai M. Josuttis", category: QNACategory.CPP, qnaMapping: qnaMapping_)
        { }

        public override string ToString()
        {
            return "CPP20CompleteGuide";
        }

        static Dictionary<int, Dictionary<string, string>> qnaMapping_ = new Dictionary<int, Dictionary<string, string>>()
        {
            {1, new Dictionary<string, string>() // Chapter 1 - Comparisons and operator<=>
                {
                    { "q", @"
What is the motiviation behind C++20's spaceship operator ('operator <=>()')?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Before C++20's spaceship operator (see snippet), you had to define six operators for a type
	to provide full support for all possible comparisons of its objects.
"
                    },
                    {"snippetA", @"
class Value
{
public:
	// equality operators
	bool operator==(const Value& rhs) const
	{
		return m_id == rhs.m_id;
	}

	bool operator!=(const Value& rhs) const
	{
		return !(*this == rhs);
	}

	// relational operators
	bool operator<(const Value& rhs) const
	{
		return m_id < rhs.m_id;
	}

	bool operator<=(const Value& rhs) const
	{
		return (*this < rhs) && (*this == rhs);
	}

	bool operator>(const Value& rhs) const
	{
		return !(*this <= rhs);
	}

	bool operator>=(const Value& rhs) const
	{
		return !(*this < rhs);
	}

private:
	long m_id;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {2, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How can we refactor the equality and relational operators with C++20's
spaceship operator?
"                   },
                    {"snippetQ", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{id}
	{}

	// equality operators
	bool operator==(const Value& rhs) const
	{
		return m_id == rhs.m_id;
	}

	bool operator!=(const Value& rhs) const
	{
		return !(*this == rhs);
	}

	// relational operators
	bool operator<(const Value& rhs) const
	{
		return m_id < rhs.m_id;
	}

	bool operator<=(const Value& rhs) const
	{
		return (*this < rhs) && (*this == rhs);
	}

	bool operator>(const Value& rhs) const
	{
		return !(*this <= rhs);
	}

	bool operator>=(const Value& rhs) const
	{
		return !(*this < rhs);
	}

private:
	long m_id;
};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{ id }
	{}

	// enable use of all equality and relational operator
	auto operator<=>(const Value&) const = default;
private:
	long m_id;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {3, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

True or false:
    Since we used a default member operator<=>, the default equality comparison
    is implicitly generated by the compiler.
"                   },
                    {"snippetQ", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{ id }
	{}

	auto operator<=>(const Value&) const = default;

	// implicitly generated
	// auto operator==(const Value&) const = default // (1)
private:
	long m_id;
};
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {4, new Dictionary<string, string>()
                {
                    { "q", @"
The new operator<=> does not return a Boolean value.

State what the return values of <=> signal:
    a) negative value
    b) 0
    c) positive value
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) a negative value signals less
b) a 0 signals equal/equivalent
c) a positive value signals greater
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {5, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'strong ordering'.
b) Give a few examples of types that have a 'strong ordering'
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In strong ordering, EVERY value v1 of a given type T is either:
    - less than or;
    - equal to or;
    - greater than
    another value v2 of the same type T.

b) integral values, common string types
    
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {6, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'weak ordering'.
b) Give a few examples of types that have a 'weak ordering'
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In weak ordering, every value v1 of a given type T is either:
    - less than or;
    - EQUIVALENT to or;
    - greater than
    another value v2 of the same type T.

b) E.g. a custom class for case-insentive comparisons of string-like objects
    ""hello"" would be equivalent to ""HELLO"" but it would not be correct to say that
    they are equal.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {7, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'partial ordering'.
b) Give a few examples of types that have a 'partial ordering'.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In partial ordering, a value v1 of type T COULD BE:
    - less than
    - equivalent to
    - greater than
    - not ordered

    another value v2 of the same type T. However, it may not be possible to specify
    a specific order between two values at all.

b) Floating point types which has special value 'NaN' - any comparison with this value
    yields false.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {8, new Dictionary<string, string>()
                {
                    { "q", @"
In the context of C++20 and beyond comparisons, outline the difference between:
    a) equality
    b) equivalence
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Let v1, v2 be values of type T

a) Equality:
    - v1 and v2 are said to be equal if (v1 == v2) is true

b) Equivalence:
    - v1 and v2 are said to be equivalent if (v1 < v2) and (v1 > v2) are false
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {9, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

State the ordering values for `yield1` to `yield4`
"                   },
                    {"snippetQ", @"
void for_main()
{
	int x{ 17 }, y{ 42 };
	
	auto yield1 = x <=> y;
	auto yield2 = x <=> 17.0;
	auto yield3 = &x <=> &x;
	auto yield4 = &x <=> nullptr;
}
"},
                    { "a", @"
See snippet for answer
"
                    },
                    {"snippetA", @"
void for_main()
{
	int x{ 17 }, y{ 42 };
	
	auto yield1 = x <=> y;			// std::strong_ordering::less
	auto yield2 = x <=> 17.0;		// std::partial_ordering::equivalent
	auto yield3 = &x <=> &x;		// std::strong_ordering::equal
	auto yield4 = &x <=> nullptr;   // Compiler error: binary operator '<=>': unsupported operand types 'int *' and 'nullptr'
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {10, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) What is the return type for operator<=> in this case?
b) How would you refactor the implementation of operator<=> in this snippet
    to enforce a std::strong_ordering
"                   },
                    {"snippetQ", @"
class Person
{
public:
	Person(std::string name, double value)
		: m_name{name}, m_value{value}
	{ }

	auto operator<=>(const Person& rhs) const
		-> std::common_comparison_category_t < decltype(std::string{} <=> std::string{}), decltype(double{} <=> double{}) >
	{
		// order by `m_name` first
		if (auto name_ordering = m_name <=> rhs.m_name; name_ordering != 0)
		{
			return name_ordering;
		}
		else // if name ordering is equal, order by `m_value` second
		{
			return m_value <=> rhs.m_value;
		}
	}
public:
	std::string m_name;
	double m_value;
};
"},
                    { "a", @"
a) std::partial_ordering (as double is the weakest form being compared and it is std::partial_ordering)

b) See snippet
"
                    },
                    {"snippetA", @"
class Person
{
public:
	Person(std::string name, double value)
		: m_name{ name }, m_value{ value }
	{
	}

	std::strong_ordering operator<=>(const Person& rhs) const
	{
		// order by `m_name` first
		if (auto name_ordering = m_name <=> rhs.m_name; name_ordering != 0)
		{
			return name_ordering;
		}
		else // if name ordering is equal, order by `m_value` second
		{
			return std::strong_order(m_value,rhs.m_value);
		}
	}
public:
	std::string m_name;
	double m_value;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {11, new Dictionary<string, string>() // Chapter 2 - Placeholder Types for Function Parameters
                {
                    { "q", @"
True or false:
a) For functions with auto parameters, the whole implementation belongs in a header file so that they can
    be used in multiple CPP files (otherwise, you have to explicitly instantiate the function in one translation unit).

b) Functions with `auto` parameters (abbreviated function templates) do not need to be declared as inline
    because function templates are always inline.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) True
b) True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {12, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Templates may be declared inside functions. Moreover, with member functions using `auto`
    parameters, you can longer define the class or data structure locally inside a function.
"                   },
                    {"snippetQ", @"
void foo()
{
	struct Data
	{
		void mem(auto param) {}
	};
}
"},
                    { "a", @"
False - the snippetQ will not compile in C++20.

Templates may NOT be declared inside functions. Moreover, with member functions using `auto`
    parameters, you can NO longer define the class or data structure locally inside a function.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {13, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How would we go about calling `print_func1` and `print_func2` with
the argument ""hello"" while also specifying the type 'std::string' explicitly.
"                   },
                    {"snippetQ", @"
#include <print>
#include <string>

void print_func1(const auto& arg)
{
	// abbreviated function template
	std::println(""print_func1: {}"", arg);
}

auto print_func2 = [](const auto& arg)
	{
		// generic lamda
		std::println(""print_func2: {}"", arg);
	};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
	print_func1<std::string>(""hello"");
	print_func2.operator()<std::string>(""Hello"");
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {14, new Dictionary<string, string>() // Chapter 3 - Concepts, Requirements, and Constraints
                {
                    { "q", @"
Consider the function template in the snippet:

How would you enhance this to guard against pointer types?
"                   },
                    {"snippetQ", @"
template<typename T>
T max_value(T a, T b)
{
	return a < b ? b : a;
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <concepts>

template<typename T>
requires(!std::is_pointer_v<T>)
T max_value(T a, T b)
{
	return a < b ? b : a;
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {15, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Constrain pointer, non-pointer abbreviated functions 
`max_value` with a standard concept to ensure that the two parameters
can be compared with each other.
"                   },
                    {"snippetQ", @"
template<typename T>
concept is_pointer = std::is_pointer_v<T>;

template<typename T>
concept is_not_pointer = !std::is_pointer_v<T>;

auto max_value(is_not_pointer auto a, is_not_pointer auto b)
{
	return a > b ? a : b;
}

auto max_value(is_pointer auto a, is_pointer auto b)
{
	return max_value(*a, *b);
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
auto max_value(is_not_pointer auto a, is_not_pointer auto b)
requires std::totally_ordered_with<decltype(a), decltype(b)>
{
	return a > b ? a : b;
}


auto max_value(is_pointer auto a, is_pointer auto b)
requires std::totally_ordered_with<decltype(*a), decltype(*b)>
{
	return max_value(*a, *b);
}

"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {16, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {17, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Outline what each of the requires subexpressions specify.
"                   },
                    {"snippetQ", @"
#include <concepts>

template<typename T>
concept is_pointer = requires(T p)
{
	*p;
	p == nullptr;
	{ p < p } -> std::same_as<bool>;
};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <concepts>

template<typename T>
concept is_pointer = requires(T p)
{
	*p;									// operator * is valid
	p == nullptr;						// can compare with nullptr NOTE: this is not saying ""equal to nullptr""
	{ p < p } -> std::same_as<bool>;	// operator< returns a bool
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {18, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) True or false:
    It is possible to constrain templated in the manner demonstrated in snippetQ

b) If (a) is a false, offer a concept implementation of `is_integral_val_type`
    that satisfies both constraints.
"                   },
                    {"snippetQ", @"
// compiler error?
template<std::ranges::sized_range T>
concept is_integral_val_type = std::integral<>std::ranges::range_value_t<T>>;
"},
                    { "a", @"
a) false - you cannot constrain concepts

b) See snippet A
"
                    },
                    {"snippetA", @"
// correct implementation 
template<typename T>
concept is_integral_val_type = std::ranges::sized_range<T> && std::integral<std::ranges::range_value_t<T>>;
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {19, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following statements regarding overload resolution's general rules and determine
whether they are true or false:
    a) Calls with no type conversion are preferred over calls having type conversion
    b) Calls of ordinary functions are preferred over calls of function templates
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) True
b) True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {20, new Dictionary<string, string>()
                {
                    { "q", @"
Carefully consider the following snippet:

Which overload gets called in `for_main`
"                   },
                    {"snippetQ", @"
#include <vector>
#include <concepts>

// overload 1
template<typename COLLECTION>
void add(COLLECTION& collection, const typename COLLECTION::value_type& value) // pass by const reference
{
	collection.push_back(value);
}


// overload 2
template<typename COLLECTION>
void add(COLLECTION& collection, typename COLLECTION::value_type value) // pass by value
	requires std::floating_point<typename COLLECTION::value_type>
{
	collection.push_back(value);
}


void for_main()
{
	std::vector<double> double_vector;	// COLLECTION::value_type is a floating point
	add(double_vector, 0.7);			// `0.7` is an r-value reference
}
"},
                    { "a", @"
Trick question:

Since the parameter value categories differ for the second argument - overload 2 is no longer
a special case of overload 1.

Therefore, we get an 'ambiguous call to overloaded function' compiler error. 
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {21, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet - which entails a custom concept.

a) What is the term for the relation between our `ConvertsWithoutNarrowing` and the
standard concept `std::convertible_to`?

b) What impact does your answer to (a) have on overload resolution?
"                   },
                    {"snippetQ", @"
template<typename From, typename To>
concept ConvertsWithoutNarrowing =
std::convertible_to<From, To>&&
	requires (From&& x) {
		{ std::type_identity_t<To[]>{std::forward<From>(x)} } -> std::same_as<To[1]>;
};

"},
                    { "a", @"
a) We say that `ConvertsWithoutNarrowing` SUBSUMES `std::convertible_to`.

b) For overload resolution purposes a concept C1 that subsumes a concept C2 considered
    more specialized - which means that a function constrained with C1 will rank higher than
    a function constrained with C2 without ambiguity issues.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {22, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet.

Rewrite the concept to:
    - only take the collection as a parameter in the requires clause
    - use std::declval to infer the underlying element type within the collection and use 
        in verifying that .push_back is supported
"                   },
                    {"snippetQ", @"
template<typename COLLECTION>
concept supports_push_back = requires(COLLECTION collection, COLLECTION::value_type value)
{
	collection.push_back(value);
};
"},
                    { "a", @"
See snippet

Note: the reference  & is required as std::declval returns an r-value reference, and we want
to leverage reference collapsing to include non-r-value references
"
                    },
                    {"snippetA", @"
#include <utility>

template<typename COLLECTION>
concept supports_push_back = requires(COLLECTION collection)
{
	collection.push_back(std::declval<typename COLLECTION::value_type&>());
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {23, new Dictionary<string, string>()
                {
                    { "q", @"
What does SFINAE:
    a) stand for and;
    b) what does it mean?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Substituion failure is not an error
b) It is a rule that we simply ignore generic code if its declaration is not well-formed
    instead of raising a compile-time error.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {24, new Dictionary<string, string>()
                {
                    { "q", @"
What is the difference between the standard concepts:
    1) std::invocable
    2) std::regular_invocable
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
1) std::invocable
    - specifies that a callable function F can be called with a set of arguments Args...

2) std::regular_invocable
    - subsumes std::invocable
    - requires the std::invoke expression to be equality-preserving
    - not modify either the function object or the arguments (not side effects)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {25, new Dictionary<string, string>()
                {
                    { "q", @"
Explain the C++20 concept (not the keyword) of 'equality preservation'.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Equality preservation means:
    - if the expression (a==b) evaluates to true
    - then given a function f, the expression (f(a) == f(b)) must also evaluate to true
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {26, new Dictionary<string, string>() // Chapter 4 - Concepts, Requirements, and Constraints in Detail
                {
                    { "q", @"
Consider the following snippet.

Why should the use of || in requires clauses NOT be used casually?
"                   },
                    {"snippetQ", @"
template<typename T>
requires std::integral<T> || std::floating_point<T>
T power(T a, T b)
{
	// implementation ...
}
"},
                    { "a", @"
The use of || in template constraints should NOT be used casually in requires
clauses as the use may potentially tax compilation resources (i.e. make compilation
noticeable slower).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {27, new Dictionary<string, string>()
                {
                    { "q", @"
Use STL only objects to define a function `foo` with
a requires clause that constrains on the following:
    1) type T is a raw pointer, or;
    2) type T is the type of nullptr
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
requires std::is_pointer_v<T> || std::same_as<T, std::nullptr_t>
void foo()
{ }
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {28, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet which shows a basic template function.

What's a quick way to disable this function (temporarily) so it doesn't
show up in the overload set?
"                   },
                    {"snippetQ", @"
template<typename T>
void print(const T&)
{
    // implementation ...
}
"},
                    { "a", @"
Use requires clause 'requires false' (see snippet)
"
                    },
                    {"snippetA", @"
template<typename T>
requires false
void print(const T&)
{
    // implementation ...
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {29, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    requires expression parameters are never replaced by arguments. Therefore,
    it usually does not matter whether you declare them by value or by reference.
"                   },
                    {"snippetQ", @"
template<typename T>
	requires requires(T x, T y) { x + y; }
[[nodiscard]] T add(T x, T y)
{
	return x + y;
}
"},
                    { "a", @"
True (although the 'usually' means that there may be some cases)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {30, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet.

Outline what each of the lines are constraining on.
"                   },
                    {"snippetQ", @"
template<typename T1, typename T2>
	requires requires(T1 t1, T2 t2)
{
	*t2;				// line (1)
	t2[0];				// line (2)
	t2->value();		// line (3)
	*t2 > t1;			// line (4)
	t2 == nullptr;		// line (5)
}
void foo() {}
"},
                    { "a", @"
See snippet.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {31, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) True or false:
    Line (1) does not that both expressions '*p > val' and 'p == nullptr' are possible
b) If we the above is true, then rewrite the requirements such that we want either expressions
    to be possible
"                   },
                    {"snippetQ", @"
template<typename T1, typename T2>
	requires requires(T1 val, T2 p)
{
	*p > val || p == nullptr; // line (1)
}
void bar() {}
"},
                    { "a", @"
a) True - this infact is requiring that the result of the expressions can be operated with the || operator
b) See snippet
"
                    },
                    {"snippetA", @"
template<typename T1, typename T2>
requires
	requires(T1 val, T2 p)
	{
		*p > val;
	}
	|| requires(T1 val, T2 p)
	{
		p == nullptr;
	}
void bar() {}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {32, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

What, if any, is the difference in constraint in (1) and (2) in terms of overload resolution? 
"                   },
                    {"snippetQ", @"
#include <concepts>

// constrained template function line (1)
template<typename T>
requires std::integral<T>
void baz() {}

// constrained template function (2)
template<typename T>
	requires requires {std::integral<T>; }
void baz() {}
"},
                    { "a", @"
The first constrained template checks for integral types.
The second constrained template checks if the expression 'std::integral<T>' is
valid - which is true for all types (yielding false is still a valid result).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {33, new Dictionary<string, string>()
                {
                    { "q", @"
Offer a concept that constrains on types T that are hashable with std::hash<T>
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
concept standard_hashable = requires {std::hash<T>{}; };
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {34, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    At both compile time and runtime, you can always use a concept where the value
    of a Boolean expression is needed. However, you cannot take the address of a concept
    because there is no object behind it (it is a pr-value)
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {35, new Dictionary<string, string>() // Chapter 6 - Ranges and Views
                {
                    { "q", @"
C++20 provieds a new way to deal with ranegs. Outline this new provision.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
- support for defining ranges and subranges as single objects
- e.g. passing ranges (or subranges) as a whole as a single argument instead of dealing with two iterators.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {36, new Dictionary<string, string>()
                {
                    { "q", @"
In the context of C++20 ranges, what is a view?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
View:
    - lightweight range
    - refers to a subset of a range
    - along with optional transformation of the values
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {37, new Dictionary<string, string>()
                {
                    { "q", @"
What was introduced in C++20 to enable a flexible way to compose
the processing of ranges and views?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Pipeline syntax
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {38, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    std::views is just an alias for std::ranges::views
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {39, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    Despite some functionality contained in the std::ranges namespace being 
    defined outside of <ranges> - you should always include the <ranges> header
    anyway.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {40, new Dictionary<string, string>()
                {
                    { "q", @"
What does the standard concept std::ranges::random_access_range require?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::ranges::random_access_range, when constraining type R, requires that R
is a range that provides random-access iterators.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {41, new Dictionary<string, string>()
                {
                    { "q", @"
State the standard concept which satisfies the following:
    a) Can be iterated from begin to end
    b) Range of elements to write values to 
    c) Range to read element values from
    d) Range you can iterate over the elements multiple times
    e) Range you can iterate over the elements forward and backward
    f) Range with random access
    g) Range with all elements in contiguous memory
    h) Range with constant-time size
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) std::ranges::range
b) std::ranges::output_range
c) std::ranges::input_range
d) std::ranges::forward_range
e) std::ranges::bidirectional_range
f) std::ranges::random_access_range
g) std::ranges::contiguous_range
h) std::ranges::sized_range
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {42, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet.

Refactor the formulation logic for the construction of `custom_view`
to use the pipeline syntax.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <ranges>
#include <numeric>
#include <iostream>
#include <algorithm>

std::vector<int> generate_arithmetic_sequence_vector(int start, std::size_t reserve_size)
{
	std::vector<int> return_vector(reserve_size);
	std::iota(return_vector.begin(), return_vector.end(), start);
	return return_vector;
}

void for_main()
{
	auto collection = generate_arithmetic_sequence_vector(1, 13);

	auto custom_view = std::views::take(
		std::views::transform(
			std::views::filter(collection,
				[](auto elem) { return elem % 3 == 0; }),
			[](auto elem) { return elem * elem; }),
		3);
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <vector>
#include <ranges>
#include <numeric>
#include <iostream>
#include <algorithm>
#include <string_view>

std::vector<int> generate_arithmetic_sequence_vector(int start, std::size_t reserve_size)
{
	std::vector<int> return_vector(reserve_size);
	std::iota(return_vector.begin(), return_vector.end(), start);
	return return_vector;
}


void for_main()
{
	auto collection = generate_arithmetic_sequence_vector(1, 13);

	auto custom_view = collection
		| std::views::filter([](auto element) {return element % 3 == 0; })
		| std::views::transform([](auto element) {return element * element; })
		| std::views::take(3);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {43, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

Write a range-based for loop over `composes` and use pipeline sytax to:
		- filter on composers born after 1700, then
		- take the first three, then
		- get a view of only the keys in this map
"                   },
                    {"snippetQ", @"
#include <map>
#include <ranges>
#include <string>
#include <iostream>

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <map>
#include <ranges>
#include <string>
#include <iostream>

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};
}

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};

	for (const auto& composer : composers
		| std::ranges::views::filter([](auto element) {return element.second > 1700;})
		| std::ranges::views::take(3)
		| std::ranges::views::keys
	)
	{
		std::cout << composer << '\n';
	}
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {44, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    Views on lvalues usually have reference semantics. This means that,
    in principle, views can be used for both reading and writing.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {45, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is lazy evaluation?
b) std::ranges::views are lazily evaluated. Outline the consequences of this.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Lazy evaluation means that computations or evaluations are deferred until
    their results are explicitly needed.

b) For std::ranges::views, this means:
    1) The elements of a range are not generated or computed upfront
    2) Computation happens on demand when elements are accessed
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {46, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    It is strongly recommended to use views right before you need them.
    Create views to use them ad hoc. If modifications happen between initializing
    a view and using it, CARE HAS TO BE TAKEN.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {47, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is a sentinel?
b) What is made possible by sentinels?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) A sentinel is:
    - an abstract that represents the end of a range
    - a generalization of the end iterator concept but does not necessarily need to
        be of the same type as the iterator

b) Sentinels make it possible to represent ranges where the end is not determined
    by an actual iterator pointing to a specific location in memory but by some condition
    or external construct.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {48, new Dictionary<string, string>()
                {
                    { "q", @"
What is the difference between:
    1) std::for_each
    2) std::ranges::for_each
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::ranges::for_each does not require that the begin iterator and the sentinel (end iterator)
have the same type.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {49, new Dictionary<string, string>()
                {
                    { "q", @"
True or false, a range can be defined by:
    a) a begin iterator and an end iterator of the same type
    b) a begin iterator and a sentinel (an end marker of possible different type to begin iterator)
    c) a begin iterator and a count 
    d) arrays
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) true
b) true
c) true
d) true
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {50, new Dictionary<string, string>()
                {
                    { "q", @"
What is the C++20 STL construct for a value that represents the ""end""
of an endless range?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::unreachable_sentinel
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {51, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How would you refactor line (1) to use projections with the stl ranges comparator for operator<? 
"                   },
                    {"snippetQ", @"
void for_main()
{
	auto iota_view = std::ranges::views::iota(-10, 11);
	std::vector<int> vector{ iota_view.begin(), iota_view.end() };
	std::ranges::sort(vector, [](const auto& lhs, const auto& rhs) {return std::abs(lhs) < std::abs(rhs); }); // line (1)
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
void for_main_qna()
{
	auto iota_view = std::ranges::views::iota(-10, 11);
	std::vector<int> vector{ iota_view.begin(), iota_view.end() };
	std::ranges::sort(vector, std::ranges::less{}, [](const auto& element) {return std::abs(element); });
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {52, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) State whether line 1 and/or line 2 lead to compile errors
b) 
    i) What is a 'borrowed iterator' and;
    ii) What problem do 'borrowed iterator's solve?
"                   },
                    {"snippetQ", @"
#include <vector>
#include <algorithm>
#include <ranges>
#include <print>
#include <iostream>

std::vector<int> get_data()
{
	auto iota_view = std::ranges::iota_view{ 30, 50 };
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto pos = std::ranges::find(get_data(), 42);
	std::println(""*pos: {}"", *pos);     // line (1)
	std::cout << *pos;					// line (2)
}
"},
                    { "a", @"
a) Both lines (1) and (2) are compile errors
    Note also that type of `pos` is std::ranges::dangling

b) i) A borrowed iterator is one that ensures that its lifetime does not
    depend on a temporary object that might have been destroyed.

   ii) Borrowed iterators solve for example the problem outlines in snippetQ.


"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {53, new Dictionary<string, string>()
                {
                    { "q", @"
a) Range types can claim that they are borrowed ranges. What is a borrowed range?
b) All lvalue containers are borrowed ranges, what does this mean concretely?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) A borrowed range means that the range's iterators can still be used when the range
itself no longer exists.

Another way of putting it is that the lifetime of the iterators does not depend on
the lifetime of the underlying (e.g. span/range).


b) The returned iterator cannot be dangling as long as the iterator exists in the same
    scope or sub-scope of the range (see snippet).
"
                    },
                    {"snippetA", @"
void for_main1()
{
	std::vector<int> collection{ 0, 8, 15 };

	// `pos8` exists in the scope of `collection`
	auto pos8 = std::ranges::find(collection, 8);
	std::cout << *pos8;
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {54, new Dictionary<string, string>()
                {
                    { "q", @"
Outline the difference between a 'range adaptor' and a 'range factory', along with 
examples of each.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Range adaptor:
    - requires an existing range
    - modifies or adapters the given range
    - examples include: std::views:: transform, filter, take, drop

Range factory:
    - Does not require an existing range (creates one itself - finite or infinite)
    - Examples include iota, single, repeat
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {55, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Why should you avoid (expensive) transformations before a filter?
"                   },
                    {"snippetQ", @"
#include <iostream>
#include <format>
#include <vector>
#include <ranges>

void for_main()
{
	std::vector<int> collection{ 8, 15, 7, 0, 9 };

	auto view = collection
		| std::views::transform([](auto element)
			{
				std::cout << std::format("" transform {}\n"", element);
				return -element;
			})
		| std::views::filter([](auto element)
			{
				std::cout << std::format("" filter {}\n"", element);
				return element % 3 == 0;
			});

	std::cout << ""*** collection | filter | transform: *** \n"";
	for (const auto& element : view)
	{
		std::cout << std::format(""element: {}\n\n"", element);
	}
}
"},
                    { "a", @"
It's all to do with the 'pull model' of views.

For example, given the following pipeline of transformations t1, t2, t3 and filters f1, f2

    t1 | t2 | f1 | t3 | f2

We have the following behaviour:

1) If f1 yields false, we call:
    - t1 t2 f1

2) If f1 yields true but f2 yields false, we call:
    - t1 t2 f1 t1 t2 t3 f2

3) If f1 yields true and f2 yields true, we call
    - t1 t2 f1 t1 t2 t3 f2 t1 t2 t3
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {56, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Views should never modify a passed argument or call a non-const operation
    for it. That way, views and their copies have the same behaviour for the same input.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <algorithm>
#include <ranges>

void for_main()
{
	auto iota_view = std::views::iota(1, 11);
	std::vector<int> collection{ iota_view.begin(), iota_view.end() };

	collection | std::views::transform(
		[](auto& value)
		{
			++value;
			return value;
		}
	);
}
"},
                    { "a", @"
True, see snippet
"
                    },
                    {"snippetA", @"
#include <vector>
#include <algorithm>
#include <ranges>

void for_main()
{
	auto iota_view = std::views::iota(1, 11);
	std::vector<int> collection{ iota_view.begin(), iota_view.end() };

	collection | std::views::transform(
		[](const auto& value) // better to use const auto&
		{
			//++value; //  modification now a compiler error
			return value;
		}
	);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {57, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet, which details the abbreviated function template
for a print function of a readable range.

Why is it prefered to pass by universal/forwarding reference instead of
const auto&?
"                   },
                    {"snippetQ", @"
void print(std::ranges::input_range auto&& range);
"},
                    { "a", @"
Because some views do not support/propogate constness.

In many cases (such as std::views::drop, std::views::filter) the begin() value is cached (meaning
the view itself is modified) such a view cannot be passed as const.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {58, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Containers (e.g. std::vector, std::array) have 'deep constness'.
    Because they have value semantics and own their elements,
    they propogate any constness to their elements.
    I.e., when a container is const, its elements are const.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <iostream>
#include <ranges>
#include <utility>
#include <type_traits>

template<typename T>
void f(T&& element) // universal references to preserve constness
{
    if constexpr (std::is_const_v<std::remove_reference_t<T>>)
    {
        std::cout << ""is const\n"";
    }
    else
    {
        std::cout << ""is NOT const\n"";
    }
}

void for_main()
{
    const std::vector<int> vector = { 1, 2, 3 };
    f(vector.at(1));
}
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {59, new Dictionary<string, string>()
                {
                    { "q", @"
True or false;
    a) std::views with ref_view semantics propagate constness
    b) std::views with owning_view semantics propagate constness
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) false - ref_view views have shallow constness
b) true 
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {60, new Dictionary<string, string>() // Chapter 7 - Utilities for Ranges and Views
                {
                    { "q", @"
For each of the following iterator categories state their:
    a) ability
    b) provider(s)

1) Output
2) Input
3) Forward
4) Bidirectional
5) Random-acess
6) Contiguous

As of C++20.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
1) Output:
    a) Writes forward
    b) ostream_iterator, inserter

2) Input:
    a) Reads forward once
    b) istream_iterator

3) Forward:
    a) Reads forward
    b) std::forward_list<>, unordered containers

4) Bidirectional
    a) Reads forward and backward
    b) std::list, std::set, std::multiset, std::map, std::multimmap

5) Random-access
    a) Reads with random access
    b) std::deque<>

6) Contiguous:
    a) Reads elements stored in contiguous memory
        subsumes random_access
    b) std::array<>, std::vector<>, std::string, c-style array
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {61, new Dictionary<string, string>()
                {
                    { "q", @"
a) State a few reason why you should prefer std::ranges:: free functions
over the std:: equivalents?

E.g.:
    - std::ranges::begin over std::begin
    - std::ranges::find over std::find

b) State any drawbacks that std::ranges:: algorithms have compares to the std:: equivalent?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) 
    1) std::ranges:: use concepts which will help to find problems and bugs
        at compile time.
    2) std::ranges:: fixes issues such as ADL and const-correctness which std:: can display

b) Parallel execution policy not available for std::ranges:: (yet)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {62, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

State the type of the resulting expression in lines:
    (1)
    (2)
"                   },
                    {"snippetQ", @"
void for_main()
{
	std::vector vector{ 1, 2, 3, 4 };
	auto pos = vector.begin();

	decltype(pos)::iterator_category;  // (1)
	decltype(pos)::iterator_concept;   // (2)
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
void for_main()
{
	std::vector vector{ 1, 2, 3, 4 };
	auto pos = vector.begin();

	decltype(pos)::iterator_category; 
	decltype(pos)::iterator_concept; 

	// below asserts compile
	static_assert(std::same_as<decltype(pos)::iterator_category,std::random_access_iterator_tag>);
	static_assert(std::same_as<decltype(pos)::iterator_concept, std::contiguous_iterator_tag>);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {63, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

If we know (for a fact) that 42 belongs in the collection that we are 
    running the find algorithm on, how would you refactor this to save on calls
    which check against the .end() each time?
"                   },
                    {"snippetQ", @"
#include <ranges>
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> get_data()
{
	// we know for a fact that 42 resides in this collection
	auto iota_view = std::views::iota(40, 50);
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto collection = get_data();
	auto pos42 = std::ranges::find(collection, 42);

	std::cout << *pos42 << '\n';
}
"},
                    { "a", @"
By using std::unreachable_sentinel, the compiler can optimize away 
the comparison with .end(), which will always yield false (see snippet).
"
                    },
                    {"snippetA", @"
#include <ranges>
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> get_data()
{
	// we know for a fact that 42 resides in this collection
	auto iota_view = std::views::iota(40, 50);
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto collection = get_data();

	//auto pos42 = std::ranges::find(collection, 42);
	auto pos42 = std::ranges::find(collection.begin(), std::unreachable_sentinel, 42);

	std::cout << *pos42 << '\n';
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {64, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is the difference between std::size and C++20's std::ssize?
b) When would you want to std::ssize?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) std::ssize returns a signed type, std::size returns std::size_t (which is unsigned)
b) If you have to use the result with other variables of signed type (e.g. arithmetic operation with int).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {65, new Dictionary<string, string>() // Chapter 9 - Spans 
                {
                    { "q", @"
True or false:
    Spans are required to only refer to elements in contiguous memory.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {66, new Dictionary<string, string>()
                {
                    { "q", @"
What is meant by the terms:
    a) fixed extent span
    b) dynamic extent span
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Fixed extent span:
    - A span with a specified number of elements

b) Dynamic extent span:
    - A span where the number of elements is not stable over its lifetime
    - Specified with a pseudo size std::dynamic_extent
        e.g. std::span<const std::string, std::dynamic_extent>
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {67, new Dictionary<string, string>()
                {
                    { "q", @"
What are the pros and cons of using std::span with a fixed vs a dynamic extent?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Fixed extent:
    - specifying a fixed size enables compilers to detect size violatinos at runtime
        or even at compile time
    - require less memory than their dynamic counterpart as they do not need to have 
        a member for the actual size (the size is part of their type)

Dynamic extent:
    - provides more flexibility.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {68, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Because spans are just a pointer and a size internally, it is
    very cheap to copy them. For this reason, you should prefer passing spans
    by value instead of passing them by const reference.
"                   },
                    {"snippetQ", @"
template<typename T, auto Sz>
void print_span(std::span<T, Sz> span)
	requires requires(T t) { std::cout << t; }
{
	for (const auto& element : span)
	{
		std::cout << std::quoted(element) << ' ';
	}
	std::cout << '\n';
}
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {69, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Does the static_assert compile? Why (not)?
"                   },
                    {"snippetQ", @"
#include <vector>
#include <array>
#include <concepts>
#include <span>

void for_main()
{
	std::array array{ 1, 2, 3, 4, 5 };
	std::vector vector {1, 2, 3, 4, 5};

	std::span<int> array_span_dyn{ array };
	std::span<int> vector_span_dyn{ vector };

	static_assert(std::same_as<decltype(array_span_dyn), decltype(vector_span_dyn)>);
}
"},
                    { "a", @"
The snippet does compile.

Because spans performs element access with raw pointers to the memory
means that a span type erases the information of where the elements are stored.

A std::span to the elements of a vector has the same type as a std::span
to the elements of an array (provided they have the same extent).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {70, new Dictionary<string, string>()
                {
                    { "q", @"
What is the major difference between std::span and std::ranges::subrange?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::span requires contiguous storage of the elements, while std::ranges::subrange
does not.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {71, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following function signature:

Add a requirement that the dereference value of the collection's .begin()
call, after removing references is const.
"                   },
                    {"snippetQ", @"
template<typename T>
void ensure_readonly_element_access(const T& collection)
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
void ensure_readonly_element_access(const T& collection)
	requires std::is_const_v<std::remove_reference_t<decltype(*collection.begin())>>
{
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {72, new Dictionary<string, string>() // Chapter 10 - Formatted Output
                {
                    { "q", @"
Memory has to be allocated for the resulting string of std::format().
To save time, you can use std::format_to_n(), which writes to a preallocated
array of characters.

Consider the following snippet:

Use 'std::format_to_n' in a templated function for array of char of NTTP SIZE
to allocate to a std::array of char.

Hint: you'll need to assign to the member representing the position of the first
    character not written.
"                   },
                    {"snippetQ", @"
void for_main()
{
	std::array<char, 64> buffer;
    // create 'write_to_buffer'
	write_to_buffer(buffer, ""test1"", ""test2"");
	std::cout << buffer.data() << '\n'; 
	// output: args: test1 and test2
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <array>
#include <format>
#include <iostream>

template<auto SIZE>
void write_to_buffer(std::array<char, SIZE>& buffer, const auto& arg1, const auto& arg2)
{
	auto ret = std::format_to_n(buffer.begin(), buffer.size() - 1, ""args: {} and {}"", arg1, arg2);
	*(ret.out) = '\0';
}

"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {73, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Will the output be 'true' or 'false'?
"                   },
                    {"snippetQ", @"
#include <string>
#include <format>
#include <iostream>

void for_main1()
{
	std::string value1;
	std::format_to(std::back_inserter(value1), ""test me: {}"", 42);

	std::string value2{ std::format(""test me: {}"", 42) };

	std::cout << std::boolalpha << (value1 == value2) << '\n';
}

"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {74, new Dictionary<string, string>()
                {
                    { "q", @"
Which free function in the <format> header should you turn to
if you wish to know in advance how many characters would be written by 
a formatted output (without actually writing any)?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
With std::formatted_size (see snippet)
"
                    },
                    {"snippetA", @"
void for_main3()
{
	std::string str{ ""imagine the size of this is determined at runtime"" };
	std::size_t threshold{ 100 };

	// if the size of the formatting output is above a certain amount...
	if (auto sz = std::formatted_size(""String '{}' has '{}' chars"", str, str.size()); sz > threshold)
	{
		// then logic
	}
	else
	{
		// else logic
	}
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {75, new Dictionary<string, string>()
                {
                    { "q", @"
True or false, compared to sprintf:
    a) std::format should be as fast or even better than sprintf
    b) std::format_to and std::format_to_n should be even better
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) True
b) True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {76, new Dictionary<string, string>()
                {
                    { "q", @"
a) True or false:
    std::format(), std::format_to(), std::format_to_n()
    require that the format string is a compile-time value.

    In other words, the snippet will false to compile.

b) If (a) is true, how would you fix snippetQ?
"                   },
                    {"snippetQ", @"
#include <iostream>
#include <format>

void for_main()
{
	const char* fmt1 = ""{}\n"";				// runtime format string
	std::cout << std::format(fmt1, 42);
}
"},
                    { "a", @"
a) True
b) See snippet
"
                    },
                    {"snippetA", @"
#include <iostream>
#include <format>

void for_main()
{
	constexpr const char* fmt1 = ""{}\n"";				// compile-time format string
	std::cout << std::format(fmt1, 42);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {77, new Dictionary<string, string>()
                {
                    { "q", @"
In what circumstance would you prefer:
    1) std::vformat
    2) std::vformat_to

Over:
    3) std::format
    4) std::format_to
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Use the v equivalents when you require computation of formatting details
at runtime (see snippet)
"
                    },
                    {"snippetA", @"
#include <format>
#include <iostream>

int main(int argc, char** argv)
{
    if (argc == 2)
    {
        const char* fmt2 = ""filename (arg1): {}, arg2: {}\n"";

        // line (1)
        std::cout << std::vformat(fmt2, std::make_format_args(argv[0], argv[1]));

        // line (2) - equivalent program functionality to line (1)
        std::vformat_to(std::ostreambuf_iterator<char>{std::cout}, fmt2, std::make_format_args(argv[0], argv[1]));
    }

    return 0;
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {78, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Format strings, and the arguments for them must have the same character type.
    In snippetQ's case, both should be 'wchar_t'
"                   },
                    {"snippetQ", @"
void for_main2()
{
	std::wstring ws2 = std::format(
		L""{}"",							// format string
		L""K\u00F6ln""					// argumet for the format string
	);
	std::wcout << ws2;
}
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {79, new Dictionary<string, string>()
                {
                    { "q", @"
a) In the context of C++20 formatting, what is meant by a 'formatter'?
b) Outside the two member functions need to be defined to satisfy a basic formatter
    API.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) A formatter is a specialization of the class template std::formatter<> for your type.

b) 
    1) std::formatter<>::parse():
        - to implement how to parse the format string specifiers for your type
    2) std::formatter<>::format():
        - to perform the actual formatting of the object/value of your type
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {80, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) Write a formatter for the 'Always40' class.

b) Furthermore, output a formatted message of an instance of 'Always40' to prove that it works.
"                   },
                    {"snippetQ", @"
class Always40
{
public:
	int get_value() const
	{
		return 40;
	}
};
"},
                    { "a", @"
OK so the quickest/easiest way to approach this is to grab the example
specialization from cppreference and customize accordingly.

source: https://en.cppreference.com/w/cpp/utility/format/formatter

See snippetA
"
                    },
                    {"snippetA", @"
#include <format>
#include <sstream>
#include <print>

class Always40
{
public:
	int get_value() const
	{
		return 40;
	}
};

template<>
struct std::formatter<Always40>
{
    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext& ctx)
    {
        auto it = ctx.begin();

        // if we're at '}'
        if (it == ctx.end())
        {
            return it;
        }

        // validation
        if (it != ctx.end() && *it != '}')
        {
            throw std::format_error(""Invalid format args for Always40."");
        }

        return it;
    }


    template<class FmtContext>
    FmtContext::iterator format(const Always40& always40, FmtContext& ctx) const
    {
        return std::format_to(ctx.out(), ""Always40({})"", always40.get_value());
    }
};


void for_main()
{
    // calls std::format under-the-hood
    std::print(""{}"", Always40{});
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {81, new Dictionary<string, string>() // Chapter 12 - std::jthread and stop tokens
                {
                    { "q", @"
What is the severe design flaw in std::thread that std::jthread addresses?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::thread is not an RAII type. std::jthread is, which means it is automatically
joined upon exited the scope of its creation.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {82, new Dictionary<string, string>()
                {
                    { "q", @"
What does std::jthread provide additionally over std::thread other than
joining on scope exit?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Additionally calls std::jthread::request_stop - which can be leveraged
by the client by passing in a std::stop_token object in the argument of the callable
passed to an instance of jthread (see snippet)
"
                    },
                    {"snippetA", @"
#pragma once
#include <chrono>
#include <thread>
#include <ranges>
#include <print>

using namespace std::literals;

void for_main()
{
	std::jthread jt0{ [](std::stop_token stop_token)
		{
			for (auto&& i : std::views::iota(0, 10))
			{
				std::println(""{}: printing value {}"", std::this_thread::get_id(), i);

				if (stop_token.stop_requested())
				{
					return;
				}
				std::this_thread::sleep_for(1s);
			}
		}
	};
	auto jt0_id = jt0.get_id();
	std::this_thread::sleep_for(5s);

	jt0.request_stop();
	std::println(""{}: stopped thread {}"", std::this_thread::get_id(), jt0_id);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {83, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet.

Instatiation a stop_callback which will simply print ""stop callback called""
to the console upon jt0::~std::jthread().

"                   },
                    {"snippetQ", @"
void task(std::stop_token stop_token, std::string string, double value)
{

}

void for_main()
{
	std::jthread jt0{ task, ""what am I going to do about it"", 0.0 };

}
"},
                    { "a", @"
See snippet.
"
                    },
                    {"snippetA", @"
#include <thread>
#include <chrono>
#include <string>
#include <print>

using namespace std::literals;


void task(std::stop_token stop_token, std::string string, double value)
{
	std::stop_callback stop_callback{
		stop_token,                                 // pass in the stop_token 
		[] {std::println(""stop callback called"");
	}};
}


void for_main()
{
	std::jthread jt0{ task, ""what am I going to do about it"", 0.0 };

}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {84, new Dictionary<string, string>()
                {
                    { "q", @"
What does std::this_thread::yield do?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Provides a hint to the implementation to reschedule the execution of threads,
allowing other threads to run.

For toy examples, this is a stand in for 'std::this_yield::sleep_for'.

See snippet
"
                    },
                    {"snippetA", @"
#include <chrono>
#include <thread>
#include <iostream>
#include <format>

using namespace std::literals;

void little_sleep(std::chrono::microseconds us)
{
	auto start = std::chrono::high_resolution_clock::now();
	auto end = start + us;

	do
	{
		std::this_thread::yield();
	} while (std::chrono::high_resolution_clock::now() < end);

}

void for_main()
{
	auto start = std::chrono::high_resolution_clock::now();
	little_sleep(100us);
	auto elapsed = std::chrono::high_resolution_clock::now() - start;

	std::format_to(
		std::ostreambuf_iterator<char>{std::cout},
		""waited for {}us"",
		std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count()
	);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {85, new Dictionary<string, string>()
                {
                    { "q", @"
What difference, if any, is there between 'active polling'
and 'busy waiting'?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Busy waiting:
    - occurs when a thread or process continuously checks for a condition
      to become true without performaning any useful work in the meantime
    - typically involves a tight loop that repeatedly checks a flag or condition,
        consuming CPU cycles unnecessarily

Active polling:
    - broader term that encompasses any repetitive checking of a condition
        (efficiently or inefficiently)
    - may also include periodic sleep or control yielding between checks
        reducing CPU usage compare to busy waiting

See snippet
"
                    },
                    {"snippetA", @"
#pragma once
#include <chrono>
#include <thread>

using namespace std::literals;

bool g_flag{ false };

void busy_waiting()
{
	while(!g_flag)
	{
		// no breaks - does nothing other than constantly check the flag
		// leads to high CPU usage
	}
}

void active_polling1()
{
	while (!g_flag)
	{
		// hint to the implementation to allow other threads to run
		std::this_thread::yield();
	}
}

void active_polling2()
{
	while (!g_flag)
	{
		// 10ms break each time
		std::this_thread::sleep_for(10ms);
	}
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {86, new Dictionary<string, string>()
                {
                    { "q", @"
What is the difference between:
    1) std::condition_variable_any
    2) std::condition_variable
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::condition_variable only works on std::unique_lock<std::mutex>, while
std::condition_variable_any can operate on any lock with meets the BasicLockable
requirements.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {87, new Dictionary<string, string>()
                {
                    { "q", @"
In the context of computing, what is the term used to describe when a thread
wakes up from waiting on a condition variable and finds that the condition is
still unsatisfied.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Spurious wakeup.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {88, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following operations and explain their effect

1) std::condition_variable_any::wait(lock_guard, stop_token, pred)
2) std::condition_variable_any::wait_for(lock_guard, duration, stop_token, pred)
3) std::condition_variable_any::wait_until(lock_guard, timepoint, stop_token, pred)
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
1) effect: waits for a notification with 'pred' being true OR stop requested
    for 'stop_token'
2) effect: waits at most duration 'duration' for notification with 'pred' being
        true or a stop requested for 'stop_token'
3) effect: waits until timepoint 'timepoint' for notification with 'pred' being
        true or a stop requested for 'stop_token'
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {89, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following requirement:

You want different threads working on different tasks and the results
need to be combined together by a main thread.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::future / std::promise
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {90, new Dictionary<string, string>() // Chapter 13: Concurrency Features
                {
                    { "q", @"
True or false:

std::barrier<COMPLETION_FUNCTION> requires the COMPLETION_FUNCTION to be marked
as noexcept?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {91, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet, which outputs characters to std::cout
in an arbitrary order.

How would you refactor this to ensure that concurrent output is synchronized (i.e
no interleaving of characters from different threads in the output)
"                   },
                    {"snippetQ", @"
#include <iostream>
#include <thread>
#include <cmath>
#include <syncstream>

void print_square_roots(int num)
{
	for (int i{ 0 }; i < num; ++i)
	{
		std::cout << ""the square root of: "" << i << "" is "" << std::sqrt(i) << '\n';
	}
}

void for_main()
{
	std::jthread jt0{ print_square_roots, 5 };
	std::jthread jt1{ print_square_roots, 5 };
	std::jthread jt2{ print_square_roots, 5 };
}
"},
                    { "a", @"
By using C++20's <syncstream> facility (see snippet).

Note that the order of the lines are still arbitrary, but you do not
get character interleaving in this case.
"
                    },
                    {"snippetA", @"
#include <iostream>
#include <thread>
#include <cmath>
#include <syncstream>

auto sync_out(std::ostream& ostream = std::cout)
{
	return std::osyncstream{ ostream };
}

void print_square_roots(int num)
{
	for (int i{ 0 }; i < num; ++i)
	{
		sync_out() << ""the square root of: "" << i << "" is "" << std::sqrt(i) << '\n';
	}
}

void for_main()
{
	std::jthread jt0{ print_square_roots, 5 };
	std::jthread jt1{ print_square_roots, 5 };
	std::jthread jt2{ print_square_roots, 5 };
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {92, new Dictionary<string, string>()
                {
                    { "q", @"
State the synchronization primitive that is useful for scenarios like:

    1) Limiting the number of threads accessing a shared resource
    2) Controlling access to pools (e.g. a thread pool or a database connection pool)
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {93, new Dictionary<string, string>()
                {
                    { "q", @"
Regarding semaphores in C++20, true or false:

    You can use them [semaphores] like mutexes, with the benefit that the threads
    granting access to a resource do not necessarily have to be the same threads that acquired
    the access to the resource.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {94, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    There is a guarantee that threads that wait the longest time are preferred.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
False - infact the contrary is usually true. If the thread scheduler already has
a thread running calling std::counting_semaphore<>::release() and said thread immediately
calls std::counting_semaphore<>::acquire(), the schedule would prefer it as there would
be no context switching in this case.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {95, new Dictionary<string, string>()
                {
                    { "q", @"
Compare and contract std::binary_semaphore with std::condition_variable
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Both synchronization primitives can be used to signal/notify a thread from another
thread. However std::binary_semaphore can conduct this signal/notify mechanism multiple times.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {96, new Dictionary<string, string>()
                {
                    { "q", @"
State the STL class template which satisfies the following description:

    [...] atomic API for trivially copying reference types. This allows you to provide
    a temporary atomic API to an existing object that is usually not atomic. One application
    would be to initialize an object without caring about concurreny and later use it with 
    different threads.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::atomic_ref<> - study the following snippet carefully.
"
                    },
                    {"snippetA", @"
#include <chrono>
#include <iostream>
#include <random>
#include <thread>
#include <vector>
#include <array>
#include <algorithm>

using namespace std::literals;

void for_main()
{
	std::array<int, 1'000> values;
	std::fill_n(values.begin(), values.size(), 100);

	std::stop_source common_stop_source;
	std::stop_token common_stop_token{ common_stop_source.get_token() };

	constexpr int THREAD_COUNT{ 9 };
	std::vector<std::jthread> jthread_vector;
	jthread_vector.reserve(THREAD_COUNT);

	for (int i{ 0 }; i < THREAD_COUNT; ++i)
	{
		jthread_vector.push_back(
			std::jthread{
				[&values](std::stop_token stop_token)
				{
					std::mt19937 mersenne_twister{std::random_device{}()};
					std::uniform_int_distribution uniform_int_distribution{ std::size_t{0}, values.size() - 1 };

					while (not stop_token.stop_requested())
					{
						auto idx = uniform_int_distribution(mersenne_twister);

						// enable atomic access to the value with the index
						// note that different threads of this program DO NOT use the same std::atomic_ref
						// objects. That is fine as std::atomic_ref<> guarantees that all concurrent access to 
						// a specific object through any std::atomic_ref<> created for it is synchronised.

						// so if two threads happen to reference the same indexed value in memory - access
						// is synchronised.
						std::atomic_ref value_atomic_ref{ values[idx] };

						// decrements the value atomically
						--value_atomic_ref;

						// loads the value atomically to compare it with 0
						if (value_atomic_ref.load() <= 0)
						{
							std::cout << std::format(""index {} is zero\n"", idx);
						}
					}
				} ,
				common_stop_token
			}
		);
	}

	std::this_thread::sleep_for(0.5s);
	std::cout << ""\nSTOP\n"";
	common_stop_source.request_stop();
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {97, new Dictionary<string, string>()
                {
                    { "q", @"
What does the compile-time static member function std::atomic<T>::is_always_lock_free() tell us?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Whether the type T uses locks internally to be atomic (false), or whether you
have native hardware support for the atomic operations (true).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {98, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {99, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {100, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {101, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {102, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {103, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {104, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {105, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {106, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {107, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {108, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {109, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {110, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {111, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {112, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {113, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {114, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {115, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {116, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {117, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {118, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {119, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {120, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {121, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {122, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {123, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {124, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {125, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {126, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {127, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {128, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {129, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {130, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {131, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {132, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {133, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {134, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {135, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {136, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {137, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {138, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {139, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {140, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {141, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {142, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {143, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {144, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {145, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {146, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {147, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {148, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {149, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {150, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {151, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {152, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {153, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {154, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {155, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {156, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {157, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {158, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {159, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {160, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {161, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {162, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {163, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {164, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {165, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {166, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {167, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {168, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {169, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {170, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {171, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {172, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {173, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {174, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {175, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {176, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {177, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {178, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {179, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {180, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {181, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {182, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {183, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {184, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {185, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {186, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {187, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {188, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {189, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {190, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {191, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {192, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {193, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {194, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {195, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {196, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {197, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {198, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {199, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {200, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },

        };

    }
}
