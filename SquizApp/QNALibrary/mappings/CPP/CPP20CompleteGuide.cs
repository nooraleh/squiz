using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QNALibrary.mappings.CPP
{
    public class CPP20CompleteGuide : QNABase
    {
        public CPP20CompleteGuide()
        : base(title: "C++20 Complete Guide by Nicolai M. Josuttis", category: QNACategory.CPP, qnaMapping: qnaMapping_)
        { }

        public override string ToString()
        {
            return "CPP20CompleteGuide";
        }

        static Dictionary<int, Dictionary<string, string>> qnaMapping_ = new Dictionary<int, Dictionary<string, string>>()
        {
            {1, new Dictionary<string, string>() // Chapter 1 - Comparisons and operator<=>
                {
                    { "q", @"
What is the motiviation behind C++20's spaceship operator ('operator <=>()')?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Before C++20's spaceship operator (see snippet), you had to define six operators for a type
	to provide full support for all possible comparisons of its objects.
"
                    },
                    {"snippetA", @"
class Value
{
public:
	// equality operators
	bool operator==(const Value& rhs) const
	{
		return m_id == rhs.m_id;
	}

	bool operator!=(const Value& rhs) const
	{
		return !(*this == rhs);
	}

	// relational operators
	bool operator<(const Value& rhs) const
	{
		return m_id < rhs.m_id;
	}

	bool operator<=(const Value& rhs) const
	{
		return (*this < rhs) && (*this == rhs);
	}

	bool operator>(const Value& rhs) const
	{
		return !(*this <= rhs);
	}

	bool operator>=(const Value& rhs) const
	{
		return !(*this < rhs);
	}

private:
	long m_id;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {2, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How can we refactor the equality and relational operators with C++20's
spaceship operator?
"                   },
                    {"snippetQ", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{id}
	{}

	// equality operators
	bool operator==(const Value& rhs) const
	{
		return m_id == rhs.m_id;
	}

	bool operator!=(const Value& rhs) const
	{
		return !(*this == rhs);
	}

	// relational operators
	bool operator<(const Value& rhs) const
	{
		return m_id < rhs.m_id;
	}

	bool operator<=(const Value& rhs) const
	{
		return (*this < rhs) && (*this == rhs);
	}

	bool operator>(const Value& rhs) const
	{
		return !(*this <= rhs);
	}

	bool operator>=(const Value& rhs) const
	{
		return !(*this < rhs);
	}

private:
	long m_id;
};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{ id }
	{}

	// enable use of all equality and relational operator
	auto operator<=>(const Value&) const = default;
private:
	long m_id;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {3, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

True or false:
    Since we used a default member operator<=>, the default equality comparison
    is implicitly generated by the compiler.
"                   },
                    {"snippetQ", @"
class Value
{
public:
	constexpr Value(long id) noexcept
		: m_id{ id }
	{}

	auto operator<=>(const Value&) const = default;

	// implicitly generated
	// auto operator==(const Value&) const = default // (1)
private:
	long m_id;
};
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {4, new Dictionary<string, string>()
                {
                    { "q", @"
The new operator<=> does not return a Boolean value.

State what the return values of <=> signal:
    a) negative value
    b) 0
    c) positive value
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) a negative value signals less
b) a 0 signals equal/equivalent
c) a positive value signals greater
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {5, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'strong ordering'.
b) Give a few examples of types that have a 'strong ordering'
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In strong ordering, EVERY value v1 of a given type T is either:
    - less than or;
    - equal to or;
    - greater than
    another value v2 of the same type T.

b) integral values, common string types
    
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {6, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'weak ordering'.
b) Give a few examples of types that have a 'weak ordering'
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In weak ordering, every value v1 of a given type T is either:
    - less than or;
    - EQUIVALENT to or;
    - greater than
    another value v2 of the same type T.

b) E.g. a custom class for case-insentive comparisons of string-like objects
    ""hello"" would be equivalent to ""HELLO"" but it would not be correct to say that
    they are equal.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {7, new Dictionary<string, string>()
                {
                    { "q", @"
There are three possible comparison categories:
    1) strong ordering
    2) weak ordering
    3) partial ordering

a) Explain 'partial ordering'.
b) Give a few examples of types that have a 'partial ordering'.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) In partial ordering, a value v1 of type T COULD BE:
    - less than
    - equivalent to
    - greater than
    - not ordered

    another value v2 of the same type T. However, it may not be possible to specify
    a specific order between two values at all.

b) Floating point types which has special value 'NaN' - any comparison with this value
    yields false.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {8, new Dictionary<string, string>()
                {
                    { "q", @"
In the context of C++20 and beyond comparisons, outline the difference between:
    a) equality
    b) equivalence
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Let v1, v2 be values of type T

a) Equality:
    - v1 and v2 are said to be equal if (v1 == v2) is true

b) Equivalence:
    - v1 and v2 are said to be equivalent if (v1 < v2) and (v1 > v2) are false
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {9, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

State the ordering values for `yield1` to `yield4`
"                   },
                    {"snippetQ", @"
void for_main()
{
	int x{ 17 }, y{ 42 };
	
	auto yield1 = x <=> y;
	auto yield2 = x <=> 17.0;
	auto yield3 = &x <=> &x;
	auto yield4 = &x <=> nullptr;
}
"},
                    { "a", @"
See snippet for answer
"
                    },
                    {"snippetA", @"
void for_main()
{
	int x{ 17 }, y{ 42 };
	
	auto yield1 = x <=> y;			// std::strong_ordering::less
	auto yield2 = x <=> 17.0;		// std::partial_ordering::equivalent
	auto yield3 = &x <=> &x;		// std::strong_ordering::equal
	auto yield4 = &x <=> nullptr;   // Compiler error: binary operator '<=>': unsupported operand types 'int *' and 'nullptr'
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {10, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) What is the return type for operator<=> in this case?
b) How would you refactor the implementation of operator<=> in this snippet
    to enforce a std::strong_ordering
"                   },
                    {"snippetQ", @"
class Person
{
public:
	Person(std::string name, double value)
		: m_name{name}, m_value{value}
	{ }

	auto operator<=>(const Person& rhs) const
		-> std::common_comparison_category_t < decltype(std::string{} <=> std::string{}), decltype(double{} <=> double{}) >
	{
		// order by `m_name` first
		if (auto name_ordering = m_name <=> rhs.m_name; name_ordering != 0)
		{
			return name_ordering;
		}
		else // if name ordering is equal, order by `m_value` second
		{
			return m_value <=> rhs.m_value;
		}
	}
public:
	std::string m_name;
	double m_value;
};
"},
                    { "a", @"
a) std::partial_ordering (as double is the weakest form being compared and it is std::partial_ordering)

b) See snippet
"
                    },
                    {"snippetA", @"
class Person
{
public:
	Person(std::string name, double value)
		: m_name{ name }, m_value{ value }
	{
	}

	std::strong_ordering operator<=>(const Person& rhs) const
	{
		// order by `m_name` first
		if (auto name_ordering = m_name <=> rhs.m_name; name_ordering != 0)
		{
			return name_ordering;
		}
		else // if name ordering is equal, order by `m_value` second
		{
			return std::strong_order(m_value,rhs.m_value);
		}
	}
public:
	std::string m_name;
	double m_value;
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {11, new Dictionary<string, string>() // Chapter 2 - Placeholder Types for Function Parameters
                {
                    { "q", @"
True or false:
a) For functions with auto parameters, the whole implementation belongs in a header file so that they can
    be used in multiple CPP files (otherwise, you have to explicitly instantiate the function in one translation unit).

b) Functions with `auto` parameters (abbreviated function templates) do not need to be declared as inline
    because function templates are always inline.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) True
b) True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {12, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Templates may be declared inside functions. Moreover, with member functions using `auto`
    parameters, you can longer define the class or data structure locally inside a function.
"                   },
                    {"snippetQ", @"
void foo()
{
	struct Data
	{
		void mem(auto param) {}
	};
}
"},
                    { "a", @"
False - the snippetQ will not compile in C++20.

Templates may NOT be declared inside functions. Moreover, with member functions using `auto`
    parameters, you can NO longer define the class or data structure locally inside a function.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {13, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How would we go able calling `print_func1` and `print_func2` with
the argument ""hello"" while also specifying the type 'std::string' explicitly.
"                   },
                    {"snippetQ", @"
#include <print>
#include <string>

void print_func1(const auto& arg)
{
	// abbreviated function template
	std::println(""print_func1: {}"", arg);
}

auto print_func2 = [](const auto& arg)
	{
		// generic lamda
		std::println(""print_func2: {}"", arg);
	};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
	print_func1<std::string>(""hello"");
	print_func2.operator()<std::string>(""Hello"");
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {14, new Dictionary<string, string>() // Chapter 3 - Concepts, Requirements, and Constraints
                {
                    { "q", @"
Consider the function template in the snippet:

How would you enhance this to guard against pointer types?
"                   },
                    {"snippetQ", @"
template<typename T>
T max_value(T a, T b)
{
	return a < b ? b : a;
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <concepts>

template<typename T>
requires(!std::is_pointer_v<T>)
T max_value(T a, T b)
{
	return a < b ? b : a;
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {15, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Constrain pointer, non-pointer abbreviated functions 
`max_value` with a standard concept to ensure that the two parameters
can be compared with each other.
"                   },
                    {"snippetQ", @"
template<typename T>
concept is_pointer = std::is_pointer_v<T>;

template<typename T>
concept is_not_pointer = !std::is_pointer_v<T>;

auto max_value(is_not_pointer auto a, is_not_pointer auto b)
{
	return a > b ? a : b;
}

auto max_value(is_pointer auto a, is_pointer auto b)
{
	return max_value(*a, *b);
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
auto max_value(is_not_pointer auto a, is_not_pointer auto b)
requires std::totally_ordered_with<decltype(a), decltype(b)>
{
	return a > b ? a : b;
}


auto max_value(is_pointer auto a, is_pointer auto b)
requires std::totally_ordered_with<decltype(*a), decltype(*b)>
{
	return max_value(*a, *b);
}

"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {16, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {17, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Outline what each of the requires subexpressions specify.
"                   },
                    {"snippetQ", @"
#include <concepts>

template<typename T>
concept is_pointer = requires(T p)
{
	*p;
	p == nullptr;
	{ p < p } -> std::same_as<bool>;
};
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <concepts>

template<typename T>
concept is_pointer = requires(T p)
{
	*p;									// operator * is valid
	p == nullptr;						// can compare with nullptr NOTE: this is not saying ""equal to nullptr""
	{ p < p } -> std::same_as<bool>;	// operator< returns a bool
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {18, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) True or false:
    It is possible to constrain templated in the manner demonstrated in snippetQ

b) If (a) is a false, offer a concept implementation of `is_integral_val_type`
    that satisfies both constraints.
"                   },
                    {"snippetQ", @"
// compiler error?
template<std::ranges::sized_range T>
concept is_integral_val_type = std::integral<>std::ranges::range_value_t<T>>;
"},
                    { "a", @"
a) false - you cannot constrain concepts

b) See snippet A
"
                    },
                    {"snippetA", @"
// correct implementation 
template<typename T>
concept is_integral_val_type = std::ranges::sized_range<T> && std::integral<std::ranges::range_value_t<T>>;
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {19, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following statements regarding overload resolution's general rules and determine
whether they are true or false:
    a) Calls with no type conversion are preferred over calls having type conversion
    b) Calls of ordinary functions are preferred over calls of function templates
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) True
b) True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {20, new Dictionary<string, string>()
                {
                    { "q", @"
Carefully consider the following snippet:

Which overload gets called in `for_main`
"                   },
                    {"snippetQ", @"
#include <vector>
#include <concepts>

// overload 1
template<typename COLLECTION>
void add(COLLECTION& collection, const typename COLLECTION::value_type& value) // pass by const reference
{
	collection.push_back(value);
}


// overload 2
template<typename COLLECTION>
void add(COLLECTION& collection, typename COLLECTION::value_type value) // pass by value
	requires std::floating_point<typename COLLECTION::value_type>
{
	collection.push_back(value);
}


void for_main()
{
	std::vector<double> double_vector;	// COLLECTION::value_type is a floating point
	add(double_vector, 0.7);			// `0.7` is an r-value reference
}
"},
                    { "a", @"
Trick question:

Since the parameter value categories differ for the second argument - overload 2 is no longer
a special case of overload 1.

Therefore, we get an 'ambiguous call to overloaded function' compiler error. 
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {21, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet - which entails a custom concept.

a) What is the term for the relation between our `ConvertsWithoutNarrowing` and the
standard concept `std::convertible_to`?

b) What impact does your answer to (a) have on overload resolution?
"                   },
                    {"snippetQ", @"
template<typename From, typename To>
concept ConvertsWithoutNarrowing =
std::convertible_to<From, To>&&
	requires (From&& x) {
		{ std::type_identity_t<To[]>{std::forward<From>(x)} } -> std::same_as<To[1]>;
};

"},
                    { "a", @"
a) We say that `ConvertsWithoutNarrowing` SUBSUMES `std::convertible_to`.

b) For overload resolution purposes a concept C1 that subsumes a concept C2 considered
    more specialized - which means that a function constrained with C1 will rank higher than
    a function constrained with C2 without ambiguity issues.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {22, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet.

Rewrite the concept to:
    - only take the collection as a parameter in the requires clause
    - use std::declval to infer the underlying element type within the collection and use 
        in verifying that .push_back is supported
"                   },
                    {"snippetQ", @"
template<typename COLLECTION>
concept supports_push_back = requires(COLLECTION collection, COLLECTION::value_type value)
{
	collection.push_back(value);
};
"},
                    { "a", @"
See snippet

Note: the reference  & is required as std::declval returns an r-value reference, and we want
to leverage reference collapsing to include non-r-value references
"
                    },
                    {"snippetA", @"
#include <utility>

template<typename COLLECTION>
concept supports_push_back = requires(COLLECTION collection)
{
	collection.push_back(std::declval<typename COLLECTION::value_type&>());
};
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {23, new Dictionary<string, string>()
                {
                    { "q", @"
What does SFINAE:
    a) stand for and;
    b) what does it mean?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Substituion failure is not an error
b) It is a rule that we simply ignore generic code if its declaration is not well-formed
    instead of raising a compile-time error.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {24, new Dictionary<string, string>()
                {
                    { "q", @"
What is the difference between the standard concepts:
    1) std::invocable
    2) std::regular_invocable
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
1) std::invocable
    - specifies that a callable function F can be called with a set of arguments Args...

2) std::regular_invocable
    - subsumes std::invocable
    - requires the std::invoke expression to be equality-preserving
    - not modify either the function object or the arguments (not side effects)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {25, new Dictionary<string, string>()
                {
                    { "q", @"
Explain the C++20 concept (not the keyword) of 'equality preservation'.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Equality preservation means:
    - if the expression (a==b) evaluates to true
    - then given a function f, the expression (f(a) == f(b)) must also evaluate to true
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {26, new Dictionary<string, string>() // Chapter 4 - Concepts, Requirements, and Constraints in Detail
                {
                    { "q", @"
Consider the following snippet.

Why should the use of || in requires clauses NOT be used casually?
"                   },
                    {"snippetQ", @"
template<typename T>
requires std::integral<T> || std::floating_point<T>
T power(T a, T b)
{
	// implementation ...
}
"},
                    { "a", @"
The use of || in template constraints should NOT be used casually in requires
clauses as the use may potentially tax compilation resources (i.e. make compilation
noticeable slower).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {27, new Dictionary<string, string>()
                {
                    { "q", @"
Use STL only objects to define a function `foo` with
a requires clause that constrains on the following:
    1) type T is a raw pointer, or;
    2) type T is the type of nullptr
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
requires std::is_pointer_v<T> || std::same_as<T, std::nullptr_t>
void foo()
{ }
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {28, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet which shows a basic template function.

What's a quick way to disable this function (temporarily) so it doesn't
show up in the overload set?
"                   },
                    {"snippetQ", @"
template<typename T>
void print(const T&)
{
    // implementation ...
}
"},
                    { "a", @"
Use requires clause 'requires false' (see snippet)
"
                    },
                    {"snippetA", @"
template<typename T>
requires false
void print(const T&)
{
    // implementation ...
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {29, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    requires expression parameters are never replaced by arguments. Therefore,
    it usually does not matter whether you declare them by value or by reference.
"                   },
                    {"snippetQ", @"
template<typename T>
	requires requires(T x, T y) { x + y; }
[[nodiscard]] T add(T x, T y)
{
	return x + y;
}
"},
                    { "a", @"
True (although the 'usually' means that there may be some cases)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {30, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet.

Outline what each of the lines are constraining on.
"                   },
                    {"snippetQ", @"
template<typename T1, typename T2>
	requires requires(T1 t1, T2 t2)
{
	*t2;				// line (1)
	t2[0];				// line (2)
	t2->value();		// line (3)
	*t2 > t1;			// line (4)
	t2 == nullptr;		// line (5)
}
void foo() {}
"},
                    { "a", @"
See snippet.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {31, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) True or false:
    Line (1) does not that both expressions '*p > val' and 'p == nullptr' are possible
b) If we the above is true, then rewrite the requirements such that we want either expressions
    to be possible
"                   },
                    {"snippetQ", @"
template<typename T1, typename T2>
	requires requires(T1 val, T2 p)
{
	*p > val || p == nullptr; // line (1)
}
void bar() {}
"},
                    { "a", @"
a) True - this infact is requiring that the result of the expressions can be operated with the || operator
b) See snippet
"
                    },
                    {"snippetA", @"
template<typename T1, typename T2>
requires
	requires(T1 val, T2 p)
	{
		*p > val;
	}
	|| requires(T1 val, T2 p)
	{
		p == nullptr;
	}
void bar() {}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {32, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

What, if any, is the difference in constraint in (1) and (2) in terms of overload resolution? 
"                   },
                    {"snippetQ", @"
#include <concepts>

// constrained template function line (1)
template<typename T>
requires std::integral<T>
void baz() {}

// constrained template function (2)
template<typename T>
	requires requires {std::integral<T>; }
void baz() {}
"},
                    { "a", @"
The first constrained template checks for integral types.
The second constrained template checks if the expression 'std::integral<T>' is
valid - which is true for all types (yielding false is still a valid result).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {33, new Dictionary<string, string>()
                {
                    { "q", @"
Offer a concept that constrains on types T that are hashable with std::hash<T>
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
concept standard_hashable = requires {std::hash<T>{}; };
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {34, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    At both compile time and runtime, you can always use a concept where the value
    of a Boolean expression is needed. However, you cannot take the address of a concept
    because there is no object behind it (it is a pr-value)
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {35, new Dictionary<string, string>() // Chapter 6 - Ranges and Views
                {
                    { "q", @"
C++20 provieds a new way to deal with ranegs. Outline this new provision.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
- support for defining ranges and subranges as single objects
- e.g. passing ranges (or subranges) as a whole as a single argument instead of dealing with two iterators.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {36, new Dictionary<string, string>()
                {
                    { "q", @"
In the context of C++20 ranges, what is a view?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
View:
    - lightweight range
    - refers to a subset of a range
    - along with optional transformation of the values
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {37, new Dictionary<string, string>()
                {
                    { "q", @"
What was introduced in C++20 to enable a flexible way to compose
the processing of ranges and views?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Pipeline syntax
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {38, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    std::views is just an alias for std::ranges::views
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {39, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    Despite some functionality contained in the std::ranges namespace being 
    defined outside of <ranges> - you should always include the <ranges> header
    anyway.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {40, new Dictionary<string, string>()
                {
                    { "q", @"
What does the standard concept std::ranges::random_access_range require?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::ranges::random_access_range, when constraining type R, requires that R
is a range that provides random-access iterators.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {41, new Dictionary<string, string>()
                {
                    { "q", @"
State the standard concept which satisfies the following:
    a) Can be iterated from begin to end
    b) Range of elements to write values to 
    c) Range to read element values from
    d) Range you can iterate over the elements multiple times
    e) Range you can iterate over the elements forward and backward
    f) Range with random access
    g) Range with all elements in contiguous memory
    h) Range with constant-time size
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) std::ranges::range
b) std::ranges::output_range
c) std::ranges::input_range
d) std::ranges::forward_range
e) std::ranges::bidirectional_range
f) std::ranges::random_access_range
g) std::ranges::contiguous_range
h) std::ranges::sized_range
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {42, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet.

Refactor the formulation logic for the construction of `custom_view`
to use the pipeline syntax.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <ranges>
#include <numeric>
#include <iostream>
#include <algorithm>

std::vector<int> generate_arithmetic_sequence_vector(int start, std::size_t reserve_size)
{
	std::vector<int> return_vector(reserve_size);
	std::iota(return_vector.begin(), return_vector.end(), start);
	return return_vector;
}

void for_main()
{
	auto collection = generate_arithmetic_sequence_vector(1, 13);

	auto custom_view = std::views::take(
		std::views::transform(
			std::views::filter(collection,
				[](auto elem) { return elem % 3 == 0; }),
			[](auto elem) { return elem * elem; }),
		3);
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <vector>
#include <ranges>
#include <numeric>
#include <iostream>
#include <algorithm>
#include <string_view>

std::vector<int> generate_arithmetic_sequence_vector(int start, std::size_t reserve_size)
{
	std::vector<int> return_vector(reserve_size);
	std::iota(return_vector.begin(), return_vector.end(), start);
	return return_vector;
}


void for_main()
{
	auto collection = generate_arithmetic_sequence_vector(1, 13);

	auto custom_view = collection
		| std::views::filter([](auto element) {return element % 3 == 0; })
		| std::views::transform([](auto element) {return element * element; })
		| std::views::take(3);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {43, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet:

Write a range-based for loop over `composes` and use pipeline sytax to:
		- filter on composers born after 1700, then
		- take the first three, then
		- get a view of only the keys in this map
"                   },
                    {"snippetQ", @"
#include <map>
#include <ranges>
#include <string>
#include <iostream>

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
#include <map>
#include <ranges>
#include <string>
#include <iostream>

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};
}

void for_main()
{
	// map of composers (name->year of birth)
	std::map<std::string, int> composers{
		{""Bach"", 1685},
		{""Mozart"", 1756},
		{""Beethoven"", 1770},
		{""Tchaikovsky"", 1840},
		{""Chopin"", 1810},
		{""Vivaldi "", 1678},
	};

	for (const auto& composer : composers
		| std::ranges::views::filter([](auto element) {return element.second > 1700;})
		| std::ranges::views::take(3)
		| std::ranges::views::keys
	)
	{
		std::cout << composer << '\n';
	}
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {44, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    Views on lvalues usually have reference semantics. This means that,
    in principle, views can be used for both reading and writing.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {45, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is lazy evaluation?
b) std::ranges::views are lazily evaluated. Outline the consequences of this.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Lazy evaluation means that computations or evaluations are deferred until
    their results are explicitly needed.

b) For std::ranges::views, this means:
    1) The elements of a range are not generated or computed upfront
    2) Computation happens on demand when elements are accessed
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {46, new Dictionary<string, string>()
                {
                    { "q", @"
True or false:
    It is strongly recommended to use views right before you need them.
    Create views to use them ad hoc. If modifications happen between initializing
    a view and using it, CARE HAS TO BE TAKEN.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {47, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is a sentinel?
b) What is made possible by sentinels?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) A sentinel is:
    - an abstract that represents the end of a range
    - a generalization of the end iterator concept but does not necessarily need to
        be of the same type as the iterator

b) Sentinels make it possible to represent ranges where the end is not determined
    by an actual iterator pointing to a specific location in memory but by some condition
    or external construct.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {48, new Dictionary<string, string>()
                {
                    { "q", @"
What is the difference between:
    1) std::for_each
    2) std::ranges::for_each
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::ranges::for_each does not require that the begin iterator and the sentinel (end iterator)
have the same type.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {49, new Dictionary<string, string>()
                {
                    { "q", @"
True or false, a range can be defined by:
    a) a begin iterator and an end iterator of the same type
    b) a begin iterator and a sentinel (an end marker of possible different type to begin iterator)
    c) a begin iterator and a count 
    d) arrays
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) true
b) true
c) true
d) true
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {50, new Dictionary<string, string>()
                {
                    { "q", @"
What is the C++20 STL construct for a value that represents the ""end""
of an endless range?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::unreachable_sentinel
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {51, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

How would you refactor line (1) to use projections with the stl ranges comparator for operator<? 
"                   },
                    {"snippetQ", @"
void for_main()
{
	auto iota_view = std::ranges::views::iota(-10, 11);
	std::vector<int> vector{ iota_view.begin(), iota_view.end() };
	std::ranges::sort(vector, [](const auto& lhs, const auto& rhs) {return std::abs(lhs) < std::abs(rhs); }); // line (1)
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
void for_main_qna()
{
	auto iota_view = std::ranges::views::iota(-10, 11);
	std::vector<int> vector{ iota_view.begin(), iota_view.end() };
	std::ranges::sort(vector, std::ranges::less{}, [](const auto& element) {return std::abs(element); });
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {52, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

a) State whether line 1 and/or line 2 lead to compile errors
b) 
    i) What is a 'borrowed iterator' and;
    ii) What problem do 'borrowed iterator's solve?
"                   },
                    {"snippetQ", @"
#include <vector>
#include <algorithm>
#include <ranges>
#include <print>
#include <iostream>

std::vector<int> get_data()
{
	auto iota_view = std::ranges::iota_view{ 30, 50 };
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto pos = std::ranges::find(get_data(), 42);
	std::println(""*pos: {}"", *pos);     // line (1)
	std::cout << *pos;					// line (2)
}
"},
                    { "a", @"
a) Both lines (1) and (2) are compile errors
    Note also that type of `pos` is std::ranges::dangling

b) i) A borrowed iterator is one that ensures that its lifetime does not
    depend on a temporary object that might have been destroyed.

   ii) Borrowed iterators solve for example the problem outlines in snippetQ.


"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {53, new Dictionary<string, string>()
                {
                    { "q", @"
a) Range types can claim that they are borrowed ranges. What is a borrowed range?
b) All lvalue containers are borrowed ranges, what does this mean concretely?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) A borrowed range means that the range's iterators can still be used when the range
itself no longer exists.

Another way of putting it is that the lifetime of the iterators does not depend on
the lifetime of the underlying (e.g. span/range).


b) The returned iterator cannot be dangling as long as the iterator exists in the same
    scope or sub-scope of the range (see snippet).
"
                    },
                    {"snippetA", @"
void for_main1()
{
	std::vector<int> collection{ 0, 8, 15 };

	// `pos8` exists in the scope of `collection`
	auto pos8 = std::ranges::find(collection, 8);
	std::cout << *pos8;
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {54, new Dictionary<string, string>()
                {
                    { "q", @"
Outline the difference between a 'range adaptor' and a 'range factory', along with 
examples of each.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Range adaptor:
    - requires an existing range
    - modifies or adapters the given range
    - examples include: std::views:: transform, filter, take, drop

Range factory:
    - Does not require an existing range (creates one itself - finite or infinite)
    - Examples include iota, single, repeat
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {55, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Why should you avoid (expensive) transformations before a filter?
"                   },
                    {"snippetQ", @"
#include <iostream>
#include <format>
#include <vector>
#include <ranges>

void for_main()
{
	std::vector<int> collection{ 8, 15, 7, 0, 9 };

	auto view = collection
		| std::views::transform([](auto element)
			{
				std::cout << std::format("" transform {}\n"", element);
				return -element;
			})
		| std::views::filter([](auto element)
			{
				std::cout << std::format("" filter {}\n"", element);
				return element % 3 == 0;
			});

	std::cout << ""*** collection | filter | transform: *** \n"";
	for (const auto& element : view)
	{
		std::cout << std::format(""element: {}\n\n"", element);
	}
}
"},
                    { "a", @"
It's all to do with the 'pull model' of views.

For example, given the following pipeline of transformations t1, t2, t3 and filters f1, f2

    t1 | t2 | f1 | t3 | f2

We have the following behaviour:

1) If f1 yields false, we call:
    - t1 t2 f1

2) If f1 yields true but f2 yields false, we call:
    - t1 t2 f1 t1 t2 t3 f2

3) If f1 yields true and f2 yields true, we call
    - t1 t2 f1 t1 t2 t3 f2 t1 t2 t3
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {56, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Views should never modify a passed argument or call a non-const operation
    for it. That way, views and their copies have the same behaviour for the same input.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <algorithm>
#include <ranges>

void for_main()
{
	auto iota_view = std::views::iota(1, 11);
	std::vector<int> collection{ iota_view.begin(), iota_view.end() };

	collection | std::views::transform(
		[](auto& value)
		{
			++value;
			return value;
		}
	);
}
"},
                    { "a", @"
True, see snippet
"
                    },
                    {"snippetA", @"
#include <vector>
#include <algorithm>
#include <ranges>

void for_main()
{
	auto iota_view = std::views::iota(1, 11);
	std::vector<int> collection{ iota_view.begin(), iota_view.end() };

	collection | std::views::transform(
		[](const auto& value) // better to use const auto&
		{
			//++value; //  modification now a compiler error
			return value;
		}
	);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {57, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the snippet, which details the abbreviated function template
for a print function of a readable range.

Why is it prefered to pass by universal/forwarding reference instead of
const auto&?
"                   },
                    {"snippetQ", @"
void print(std::ranges::input_range auto&& range);
"},
                    { "a", @"
Because some views do not support/propogate constness.

In many cases (such as std::views::drop, std::views::filter) the begin() value is cached (meaning
the view itself is modified) such a view cannot be passed as const.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {58, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Containers (e.g. std::vector, std::array) have 'deep constness'.
    Because they have value semantics and own their elements,
    they propogate any constness to their elements.
    I.e., when a container is const, its elements are const.
"                   },
                    {"snippetQ", @"
#include <vector>
#include <iostream>
#include <ranges>
#include <utility>
#include <type_traits>

template<typename T>
void f(T&& element) // universal references to preserve constness
{
    if constexpr (std::is_const_v<std::remove_reference_t<T>>)
    {
        std::cout << ""is const\n"";
    }
    else
    {
        std::cout << ""is NOT const\n"";
    }
}

void for_main()
{
    const std::vector<int> vector = { 1, 2, 3 };
    f(vector.at(1));
}
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {59, new Dictionary<string, string>()
                {
                    { "q", @"
True or false;
    a) std::views with ref_view semantics propagate constness
    b) std::views with owning_view semantics propagate constness
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) false - ref_view views have shallow constness
b) true 
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {60, new Dictionary<string, string>() // Chapter 7 - Utilities for Ranges and Views
                {
                    { "q", @"
For each of the following iterator categories state their:
    a) ability
    b) provider(s)

1) Output
2) Input
3) Forward
4) Bidirectional
5) Random-acess
6) Contiguous

As of C++20.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
1) Output:
    a) Writes forward
    b) ostream_iterator, inserter

2) Input:
    a) Reads forward once
    b) istream_iterator

3) Forward:
    a) Reads forward
    b) std::forward_list<>, unordered containers

4) Bidirectional
    a) Reads forward and backward
    b) std::list, std::set, std::multiset, std::map, std::multimmap

5) Random-access
    a) Reads with random access
    b) std::deque<>

6) Contiguous:
    a) Reads elements stored in contiguous memory
        subsumes random_access
    b) std::array<>, std::vector<>, std::string, c-style array
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {61, new Dictionary<string, string>()
                {
                    { "q", @"
a) State a few reason why you should prefer std::ranges:: free functions
over the std:: equivalents?

E.g.:
    - std::ranges::begin over std::begin
    - std::ranges::find over std::find

b) State any drawbacks that std::ranges:: algorithms have compares to the std:: equivalent?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) 
    1) std::ranges:: use concepts which will help to find problems and bugs
        at compile time.
    2) std::ranges:: fixes issues such as ADL and const-correctness which std:: can display

b) Parallel execution policy not available for std::ranges:: (yet)
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {62, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

State the type of the resulting expression in lines:
    (1)
    (2)
"                   },
                    {"snippetQ", @"
void for_main()
{
	std::vector vector{ 1, 2, 3, 4 };
	auto pos = vector.begin();

	decltype(pos)::iterator_category;  // (1)
	decltype(pos)::iterator_concept;   // (2)
}
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
void for_main()
{
	std::vector vector{ 1, 2, 3, 4 };
	auto pos = vector.begin();

	decltype(pos)::iterator_category; 
	decltype(pos)::iterator_concept; 

	// below asserts compile
	static_assert(std::same_as<decltype(pos)::iterator_category,std::random_access_iterator_tag>);
	static_assert(std::same_as<decltype(pos)::iterator_concept, std::contiguous_iterator_tag>);
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {63, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

If we know (for a fact) that 42 belongs in the collection that we are 
    running the find algorithm on, how would you refactor this to save on calls
    which check against the .end() each time?
"                   },
                    {"snippetQ", @"
#include <ranges>
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> get_data()
{
	// we know for a fact that 42 resides in this collection
	auto iota_view = std::views::iota(40, 50);
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto collection = get_data();
	auto pos42 = std::ranges::find(collection, 42);

	std::cout << *pos42 << '\n';
}
"},
                    { "a", @"
By using std::unreachable_sentinel, the compiler can optimize away 
the comparison with .end(), which will always yield false (see snippet).
"
                    },
                    {"snippetA", @"
#include <ranges>
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> get_data()
{
	// we know for a fact that 42 resides in this collection
	auto iota_view = std::views::iota(40, 50);
	return { iota_view.begin(), iota_view.end() };
}

void for_main()
{
	auto collection = get_data();

	//auto pos42 = std::ranges::find(collection, 42);
	auto pos42 = std::ranges::find(collection.begin(), std::unreachable_sentinel, 42);

	std::cout << *pos42 << '\n';
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {64, new Dictionary<string, string>()
                {
                    { "q", @"
a) What is the difference between std::size and C++20's std::ssize?
b) When would you want to std::ssize?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) std::ssize returns a signed type, std::size returns std::size_t (which is unsigned)
b) If you have to use the result with other variables of signed type (e.g. arithmetic operation with int).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {65, new Dictionary<string, string>() // Chapter 9 - Spans 
                {
                    { "q", @"
True or false:
    Spans are required to only refer to elements in contiguous memory.
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
True.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {66, new Dictionary<string, string>()
                {
                    { "q", @"
What is meant by the terms:
    a) fixed extent span
    b) dynamic extent span
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
a) Fixed extent span:
    - A span with a specified number of elements

b) Dynamic extent span:
    - A span where the number of elements is not stable over its lifetime
    - Specified with a pseudo size std::dynamic_extent
        e.g. std::span<const std::string, std::dynamic_extent>
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {67, new Dictionary<string, string>()
                {
                    { "q", @"
What are the pros and cons of using std::span with a fixed vs a dynamic extent?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
Fixed extent:
    - specifying a fixed size enables compilers to detect size violatinos at runtime
        or even at compile time
    - require less memory than their dynamic counterpart as they do not need to have 
        a member for the actual size (the size is part of their type)

Dynamic extent:
    - provides more flexibility.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {68, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

True or false:
    Because spans are just a pointer and a size internally, it is
    very cheap to copy them. For this reason, you should prefer passing spans
    by value instead of passing them by const reference.
"                   },
                    {"snippetQ", @"
template<typename T, auto Sz>
void print_span(std::span<T, Sz> span)
	requires requires(T t) { std::cout << t; }
{
	for (const auto& element : span)
	{
		std::cout << std::quoted(element) << ' ';
	}
	std::cout << '\n';
}
"},
                    { "a", @"
True
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {69, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following snippet:

Does the static_assert compile? Why (not)?
"                   },
                    {"snippetQ", @"
#include <vector>
#include <array>
#include <concepts>
#include <span>

void for_main()
{
	std::array array{ 1, 2, 3, 4, 5 };
	std::vector vector {1, 2, 3, 4, 5};

	std::span<int> array_span_dyn{ array };
	std::span<int> vector_span_dyn{ vector };

	static_assert(std::same_as<decltype(array_span_dyn), decltype(vector_span_dyn)>);
}
"},
                    { "a", @"
The snippet does compile.

Because spans performs element access with raw pointers to the memory
means that a span type erases the information of where the elements are stored.

A std::span to the elements of a vector has the same type as a std::span
to the elements of an array (provided they have the same extent).
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {70, new Dictionary<string, string>()
                {
                    { "q", @"
What is the major difference between std::span and std::ranges::subrange?
"                   },
                    {"snippetQ", @"
"},
                    { "a", @"
std::span requires contiguous storage of the elements, while std::ranges::subrange
does not.
"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {71, new Dictionary<string, string>()
                {
                    { "q", @"
Consider the following function signature:

Add a requirement that the dereference value of the collection's .begin()
call, after removing references is const.
"                   },
                    {"snippetQ", @"
template<typename T>
void ensure_readonly_element_access(const T& collection)
"},
                    { "a", @"
See snippet
"
                    },
                    {"snippetA", @"
template<typename T>
void ensure_readonly_element_access(const T& collection)
	requires std::is_const_v<std::remove_reference_t<decltype(*collection.begin())>>
{
}
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {72, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {73, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {74, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {75, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {76, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {77, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {78, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {79, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {80, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {81, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {82, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {83, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {84, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {85, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {86, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {87, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {88, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {89, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {90, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {91, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {92, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {93, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {94, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {95, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {96, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {97, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {98, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {99, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {100, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {101, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {102, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {103, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {104, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {105, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {106, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {107, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {108, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {109, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {110, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {111, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {112, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {113, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {114, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {115, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {116, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {117, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {118, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {119, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {120, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {121, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {122, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {123, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {124, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {125, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {126, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {127, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {128, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {129, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {130, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {131, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {132, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {133, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {134, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {135, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {136, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {137, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {138, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {139, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {140, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {141, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {142, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {143, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {144, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {145, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {146, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {147, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {148, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {149, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {150, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {151, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {152, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {153, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {154, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {155, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {156, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {157, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {158, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {159, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {160, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {161, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {162, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {163, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {164, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {165, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {166, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {167, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {168, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {169, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {170, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {171, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {172, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {173, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {174, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {175, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {176, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {177, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {178, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {179, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {180, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {181, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {182, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {183, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {184, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {185, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {186, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {187, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {188, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {189, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {190, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {191, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {192, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {193, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {194, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {195, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {196, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {197, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {198, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {199, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },
            {200, new Dictionary<string, string>()
                {
                    { "q", @"

"                   },
                    {"snippetQ", @"
"},
                    { "a", @"

"
                    },
                    {"snippetA", @"
"
                    },
                    {"imgQ", @"
"
                    },
                    {"imgA", @"
"
                    },
                }
            },

        };

    }
}
