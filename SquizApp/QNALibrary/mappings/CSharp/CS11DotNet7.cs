using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QNALibrary.mappings.CSharp
{
    public partial class CS11DotNet7 : QNABase
    {
        public CS11DotNet7()
        : base(title: "Mark J Price's C#11 and .NET 7 Modern Cross-Platform Development Fundamentals", category: QNACategory.CSharp, qnaMapping: qnaMapping_)
        { }

        public override string ToString()
        {
            return "CS11DotNet7";
        }

        static Dictionary<int, Dictionary<string, string>> qnaMapping_ = new Dictionary<int, Dictionary<string, string>>() {
    {1, new Dictionary<string, string>() {
        {"q", @"1) Explain what the following terms refer to:
			a) modern .NET
			b) legacy .NET

		2) What is 'modern .NET' is relation to 'legacy .NET'?"},
        {"a", @"1)
			a) modern .NET refers to .NET7 and it's predecessors like .NET5, .NET6
			b) legacy .NET refers to .NET Framework, Mono, Xamarin and .NET standard

		2) Modern .NET is a unification of the legacy .NET platforms and standards"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {2, new Dictionary<string, string>() {
        {"q", @"#TODO: Understanding .NET 53/419"},
        {"a", @""},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {3, new Dictionary<string, string>() {
        {"q", @"In the context of .NET releases, what is understood by:
			1) Long Term Support (LTS)
			2) Standard Support (formerly known as Current)
			3) Preview
			4) End of life/end of support"},
        {"a", @"1) LTS:
				- releases are stable and require fewwer updates over their lifetime
				- are a good choice for applications that you do not intend to update frequently

			2) Standard support
				- releases include features that may change based on feedback
				- are a good choice for applications you are actively developing because they
					provide access to the latest improvements

			3) Preview
				- releases are for public testing
				- good choice for adventurous programmers who want to live on the bleeding edge
				- are not supported by Microsoft unless declared 'Go Live'

			4) End of life/end of support
				- the date after which bug fixes, security updates, and technical assistance
					are no longer available from Microsoft"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {4, new Dictionary<string, string>() {
        {"q", @"What is the .NET language compiler for C# and Visual Basic also known as?"},
        {"a", @"Roslyn. Note that Roslyn, along with the F# compiler, is distributed as part of the
		.NET software development kit."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {5, new Dictionary<string, string>() {
        {"q", @"To display your understanding of the term  'importing the namespace' - write a quick
		line to import the 'System' namespace?"},
        {"a", @"answer:
			using System;"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {6, new Dictionary<string, string>() {
        {"q", @"When you create a new C# project 'Example' with a .NET target of 6.0 (or > 6.0), a file
		with the format <ProjectName>.GlobalUsings.g.cs is created for you - in this case it
		would be named Example.GlobalUsings.g.cs - what does the 'g' in the extension '.g.cs'
		stand for?"},
        {"a", @"The 'g' stands for 'generated' to:
			1) distinguish '.g.cs' from ordinary '.cs' files
			2) since the file is auto-generated by the compiler"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {7, new Dictionary<string, string>() {
        {"q", @"What is a 'type-forwarder'?"},
        {"a", @"A type-forwarder is a type that has been implemented outside of .NET
		or for some other advanced reason. The 'System.Runtime' assembly only contains
		type-forwarders."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {8, new Dictionary<string, string>() {
        {"q", @"Which keyword would you use to get the name of the variable out?"},
        {"a", @"nameof"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {9, new Dictionary<string, string>() {
        {"q", @"What is the syntactic difference between verbatim strings and raw string literals?"},
        {"a", @"Verbatim strings:
			start with @"" and end with ""

		Raw literal strings:
			Start and end with three or more """},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {10, new Dictionary<string, string>() {
        {"q", @"Consider the following snippet:
			 string json_example = $$ """"""
			 {
				""first_name"": ""{{person.FirstName}}"",
			 	""age"": ""{{person.Age}}""
			 }
			 """""";

		What does the $$ at the beginning of the raw interpolated string
		literal indicate?"},
        {"a", @"The number of dollars signs tells the compiler how many curly braces
		are needed for something to become recognized as an interpolated expression. In this case,
		since we have two $ this means we require two nested curly braces."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {11, new Dictionary<string, string>() {
        {"q", @"Why is the `decimal` type more accurate under-the-hood then the `double` type."},
        {"a", @"Because `decimal` stores the number as a large integer and shifts the decimal point
		all the way to the right.
		
		E.g 0.1M is stored internal as 1 so there will be 1 bit, 12.75 is stored
		as 1275 and so on.
		
		This is opposed to how 0.1d is stored as an a recurring sequence of bits."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {12, new Dictionary<string, string>() {
        {"q", @"a) What is the name of the special type that can store any type of data in C#?
		b) What are the downsides to this flexibility?
		c) What is a better alternative to your answer in (a) as of C# 2.0"},
        {"a", @"a) `object`
		b) Downsides: 1) readability/understandability 2) possibly poor performance
		c) Using generics - as these will probide us with the flexibility that we want, but
			without the performance overhead."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {13, new Dictionary<string, string>() {
        {"q", @"What are some of the pros and cons of using the `dynamic` keyword?"},
        {"a", @"Pro:
			- The value stored in the variable can have its members invoked without
				an explicit cast.

		Con:
			- Even more of a performace cost than using `object` - which would require
				an explicit cast."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {14, new Dictionary<string, string>() {
        {"q", @"Explain the implications of C# 9's 'target-typed new'."},
        {"a", @"'target-typed new' you can specify the type of the LHS of the assignment
		expression without having to specify the type on the LHS.

		E.g.
			Person kim = new(); // equivalent to Person kim = new Person();"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {15, new Dictionary<string, string>() {
        {"q", @"Which keyword can you use to get the default value of a type?
		For example, the default value of type `int` in C# is 0 - how can you get this out?"},
        {"a", @"Answer: The `default` keyword. For `int`, we would write:
			default(int)"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {16, new Dictionary<string, string>() {
        {"q", @"Reference type variables contain the memory address of a value, not the value itself.
		A reference type variable can have a `null` value, which is a literal that indicates
		that the variable does not reference anything. What is the default for all reference types?"},
        {"a", @"The default for all reference types is `null`"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {17, new Dictionary<string, string>() {
        {"q", @"What is one reason to avoid interpolated strings in C#?"},
        {"a", @"Interpolated strings can't be read from resource files to be localized."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {18, new Dictionary<string, string>() {
        {"q", @"Consider the snippets:
			string? first_name = Console.ReadLine(); (1)
			string age = Console.ReadLine()!;        (2)

		a) What does the ? after the `string` type declaration signify to the compiler?
		b) What is the consequence of the ! in line (2)"},
        {"a", @"a) The ? signifies that we are expecting a possible null value so no need to warn us.
		b) The !, known as the null-forgiving operator, tells the compiler that `Console.ReadLine()` will NOT
			return `null`, so it can stop showing a warning. It is now our responsibility to ensure that it will
			not return `null`."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {19, new Dictionary<string, string>() {
        {"q", @"True or false:
			In C#6.0 and later, the `using` statement can be used not only to import our namespace
			but also to further simplify our code by importing a static class."},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {20, new Dictionary<string, string>() {
        {"q", @"True or false:
			In C#, binary shift operators can perform multiplcation/division by 2 much faster than
			the tradition *2 or /2"},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {21, new Dictionary<string, string>() {
        {"q", @"In the context of switch/case statements, which of the following statements are true or false:
			a) In C++, the positioning of default: matters and any cases after it will not be called
			b) In C#, the positioning of default: matters and any cases after it will not be called"},
        {"a", @"a) true, it matters in C++
			b) false, it does not matter in C# and default: will always be evaluated last"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {22, new Dictionary<string, string>() {
        {"q", @"In C#, what is the '_' character used to represent the default value of a switch expression known
		as ?"},
        {"a", @"A discard."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {23, new Dictionary<string, string>() {
        {"q", @"State the kind of array which is associate with the following syntax:
			a) string[][] array1
			b) sting[,] array2"},
        {"a", @"a) jagged array syntax (a.k.a array of arrays) (does not require all elements within dimension bounds to be populated)
			b) multi-dimensional array syntax (requires all elements within dimension bounds to be populated)"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {24, new Dictionary<string, string>() {
        {"q", @"When would you want to prefer an array (e.g. T[]) over a collection (e.g. List<T>)?"},
        {"a", @"You would prefer an array over a collection when you will not be dynamically adding and removing
		items."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {25, new Dictionary<string, string>() {
        {"q", @"Which class is capable of converting to and from all the C# number types, as well as Booleans,
		strings, and date and time values?"},
        {"a", @"The `System.Convert` type is capable of such conversion. Import with:
			using System.Convert
		And use one of the conversion methods e.g.
			double g = 9.8D;
			int h = System.Convert.ToInt32(g);"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {26, new Dictionary<string, string>() {
        {"q", @"True or false:
			Since the System.Object class implements a .ToString() method, all C# objects
			also have the .ToString() method available to be called?s"},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {27, new Dictionary<string, string>() {
        {"q", @"All C# objects have access to a .ToString() method - which, if correctly implemented, allows
		for a string representation of the given C# object.

		What is the opposite operation of .ToString()."},
        {"a", @"The opposite of ToString is Parse(). We use Parse() to convert from a string to another C# object,
		such as an arithmetic type like int or a DateTime object."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {28, new Dictionary<string, string>() {
        {"q", @"What is a safer method than .Parse() to use if you want to parse a string into another C# object?"},
        {"a", @"TryParse"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {29, new Dictionary<string, string>() {
        {"q", @"What are `checked` and `unchecked` statements used for in C#?"},
        {"a", @"They specify whether or not to enable the overflow-checking context for
		integral-type arithmetic operations and conversions.
		
		`checked` enables the context meaning System.OverflowException would be thrown at runtime,
		and a compile-time error if we are in a constant expression.

		`unchecked` disables such measures."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {30, new Dictionary<string, string>() {
        {"q", @"How should you approach writing a function that you will call in Program.cs?"},
        {"a", @"1) Create a separate file (e.g Program.other.cs)
		2) manually define them inside a `partial Program` class
		3) the compiler will merge your defined functions into the automatocally generated `Program`
			class at the same level as the <Main>$ method"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {31, new Dictionary<string, string>() {
        {"q", @"Consider C++'s 'destructor' special member function. What is the equivalent C#
		member called?"},
        {"a", @"Finalizer"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {32, new Dictionary<string, string>() {
        {"q", @"In Visual Studio 2022, which shortcut allows you to access the tool-tip bar?"},
        {"a", @"ctrl+."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {33, new Dictionary<string, string>() {
        {"q", @"a) What are expression-bodied members?
		b) When should you turn to expression-bodied members?"},
        {"a", @"a) Expression-bodied members have the following syntax
				member => expression;

			Note that there are no curly braces which is the norm for languages like C#, C++ etc
			Note also the lack of a return statement

		b) You should turn to expression-bodies members whenever the logic for any supported member,
			such as a method or property, consists of a single expression."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {34, new Dictionary<string, string>() {
        {"q", @"In VS 2022, what is the keyboard shortcut you can use to toggle debugging?"},
        {"a", @"F9"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {35, new Dictionary<string, string>() {
        {"q", @"In VS 2022, what is the keyboard shortcut you can use to run with debugging?"},
        {"a", @"F5"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {36, new Dictionary<string, string>() {
        {"q", @"What is .NET hot reloading?"},
        {"a", @"With Hot Reload, you can now modify your apps managed suorce code while the application
		is running, without the need to manually pause or hit breakpoint."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {37, new Dictionary<string, string>() {
        {"q", @"What could be understood by the term 'instrument your code'?"},
        {"a", @"To 'instrument your code' could be understood as 'logging events of interest'."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {38, new Dictionary<string, string>() {
        {"q", @"What is the key difference between:
			1) Trace.WriteLine
			2) Debug.WriteLine"},
        {"a", @"Trace.WriteLine is written to in both release and debug configurations, while Debug.WriteLine
			is only written to when the program is run in debug configuration."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {39, new Dictionary<string, string>() {
        {"q", @"Consider the following function signature:
			(string address, bool isValidAddress) ValidateAddress(string address)

		And the following example invocation:
			(string message, bool isValid) = ValidateAddress(""123 sesame st""); (1)

		What is the term for the assignment taking placing in line (1)?"},
        {"a", @"Deconstructor"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {40, new Dictionary<string, string>() {
        {"q", @"What is a class library?"},
        {"a", @"A class library is a package of code that can be distributed and referenced by other
		.NET applications."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {41, new Dictionary<string, string>() {
        {"q", @"A well-written unit test will have three parts, what are they?"},
        {"a", @"1) Arrange
			- declare and instantiate variables for input and output
		2) Act
			- executing the unit that we are testing e.g. calling the method that
			  we want to test.
		3) Assert
			- make one or more assertions about the output."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {42, new Dictionary<string, string>() {
        {"q", @"Consider the line:
			int i = 0; (1)

		a) True or false: int is a value type
		b) How can we change line (1) to allow i to be nullable (i.e i is allowed to hold 'null')"},
        {"a", @"a) true
		b) int? i = 0;"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {43, new Dictionary<string, string>() {
        {"q", @"Consider the following .csproj snippet:
				<Project Sdk=""Microsoft.NET.Sdk"">
					<PropertyGroup>
						<OutputType>Exe</OutputType>
						<TargetFramework>net7.0</TargetFramework>
						<ImplicitUsings>enable</ImplicitUsings>
						<Nullable>enable</Nullable>                      (1)
					</PropertyGroup>
				</Project>


		What is the fancy word for line (1)?"},
        {"a", @"The fancy word is 'nullable annotation context' - if enabled, nullable types will have
		to be marked as T? to convey to the compiler that you expect the value to potentially be null.

		Generates warning if we do not do so."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {44, new Dictionary<string, string>() {
        {"q", @"Consider the following snippet:
			PersonModel p = null;
			if(p.Name.Length > 0)               (1)
			{
				Console.WriteLine(p.Name.Length);
			}

		a) What change can we make to line (1) to ensure that non-null `PersonModel`
			variables do not have there .Name.Length methods accessed?

		b) What is the term for your answer to (a)"},
        {"a", @"a) Answer:
				if(p?.Name.Length > 0) 

		b) Null conditional operator"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {45, new Dictionary<string, string>() {
        {"q", @"Give an example use case of the null-coalescing operator to demonstrate your understanding/"},
        {"a", @"Well the null-coalescing operator is a binary operator ?? which prefers the LHS operator but if
		it is null will prefer the RHS operand, which is usually a default value. E.g.

			string s = null;
			string s1 = s ?? ""default string!"";

		In this case, the null coalescing operator is functionally equivalent to:
			string s1;
			if (s is not null)
			{
				s1 = s;
			}
			else
			{
				s1 = ""default string"";
			}"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {46, new Dictionary<string, string>() {
        {"q", @"What is the implicit access modifier for a class i.e. if we do not explicit specify
		an access modifier for a class like 'public', what will the compiler default to?"},
        {"a", @"internal"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {47, new Dictionary<string, string>() {
        {"q", @"Why is the enum type an efficient way of storing on or more choices?"},
        {"a", @"Because, internally, it uses integer values in combination with a lookup table
		of string descriptions."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {48, new Dictionary<string, string>() {
        {"q", @"Consider the following snippet:

			private string _ssn;

			public string SSN
			{
				get => ""***-***-1234"";
				set { _ssn = value; }
			}

		What is the official term for:
			a) `SsN`
			b) `_ssn`"},
        {"a", @"a) Property
		b) Backing (storage) field"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {49, new Dictionary<string, string>() {
        {"q", @"Consider the following snippet, which defined a property using C# 3.0 syntax?

			public string? FavouriteMovie {get; set}

		What is the term for the syntax in '{get; set}'"},
        {"a", @"Auto-syntax"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {50, new Dictionary<string, string>() {
        {"q", @"TODO: required modifier"},
        {"a", @""},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {51, new Dictionary<string, string>() {
        {"q", @"Best practice true or false:

			a) A method that creates a new object, or modifies an existing object, should return a reference
				to that object so that the caller can access those results.
			b) The return type for an operator can be different from the type(s) of the parameters, however the
				return type cannot be void."},
        {"a", @"a) True
		b) True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {52, new Dictionary<string, string>() {
        {"q", @"C# 7.0 introduced the ability to define local functions, what are local functions?"},
        {"a", @"Local functions are methods that are only accessible with the containing method in which
		they have been defined. Other languages would describe this as 'nested' or 'inner' functions."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {53, new Dictionary<string, string>() {
        {"q", @"TODO: records"},
        {"a", @""},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {54, new Dictionary<string, string>() {
        {"q", @"Which keyword would you use to specify that a field can only be set during instantiation?"},
        {"a", @"The `init` keyword, which is used in the stead of the `set` keyword e.g.
				public string? FirstName {get; init}"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {55, new Dictionary<string, string>() {
        {"q", @"What is the difference between:
			a) Equals
			b) ReferenceEquals

		in C#?"},
        {"a", @"`Equals` will compare for equality preferring the equality operator for the type you passed in,
		`ReferenceEquals` will compare for equality of the address of disk, regarding if there is a value-based
		equality operator defined in the class. Think is `ReferenceEquals` like the `is` keyword in Python."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {56, new Dictionary<string, string>() {
        {"q", @"Why should you prefer types in System.Collections.Generic as opposed to types
		in Systems.Collections?"},
        {"a", @"Because the types in System.Collections.Generic constrain the types to be templated
		on a type T, whereas data structures in Systems.Collections use System.Object as the type - 
		which is extremely error prone and less performant as there is no type-checking."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {57, new Dictionary<string, string>() {
        {"q", @"a) What is understood by an 'event'?
		b) What is the model upon which C# events are based on?
		c) Which design pattern does your answer to (b) follow?"},
        {"a", @"a) An event is a message sent by an object to signal the occurrence of an action.
		b) Delegate model
		c) Observer design pattern - which enables a subscriber to register with and receive
			notifications from a provider."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {58, new Dictionary<string, string>() {
        {"q", @"If you want to sort an array or collection of instances of your type,
		which interface should you implement?"},
        {"a", @"The IComparable interface."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {59, new Dictionary<string, string>() {
        {"q", @"In C#, what is the difference between:
			a) Defining a `record` or `class`, and;
			b) Defining a `record struct` or `struct`"},
        {"a", @"Defining a `record` or `class`:
			- you are defining a reference type
			- this means the memory for the object itself is allocated on the heap
			- only the memory address for the object (and a little overhead) is stored on the stack

		Defining a `record struct` or `struct`:
			- you are defining a value type
			- the entails memory for the object being allocated to the stack"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {60, new Dictionary<string, string>() {
        {"q", @"True or false:
			In C#, you can inherit from a struct."},
        {"a", @"False"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {61, new Dictionary<string, string>() {
        {"q", @"True or false:
			a) Suffixing a reference type T with ? changes the type to Nullable<T>
			b) Suffixing a value type T with ? changes the type to Nullable<T>"},
        {"a", @"a) false - the reference type does not change it's type
		b) true"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {62, new Dictionary<string, string>() {
        {"q", @"I have a base class `BaseClass` with a function `f`, I derive from the base class
		`DerivedClass` and want to write a function named `f` in `DerivedClass`, which keyword
		should I use if I want to:
			a) hide BaseClass.f
			b) override BaseClass.f"},
        {"a", @"a) new (this is known as non-polymorphic inheritance)
			b) override (this is known as polymorphic inheritance)"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {63, new Dictionary<string, string>() {
        {"q", @"a) Which keyword allows for preventing a class from being derived? I.e. the C# equivalent
		of C++'s `final` keyword

		b) Give a quick example of your answer to (a)

		c) true or false:
				The `sealed` keyword can only be applied to classes"},
        {"a", @"a) `sealed` 
		b)	snippet:
				public sealed class ScroogeMcDuck
				{

				}

		c) false, you can use `sealed` on overriden methods as well to prevent derived classes from overriding
			the method."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {64, new Dictionary<string, string>() {
        {"q", @"What is the difference between casting and converting?"},
        {"a", @"Casting is going from and to similar types e.g. 16-bit integer to 32-bit integer, over between
		a sub-class and a super-class.

		Converting is between dissimilar types e.g. a text-based type (such as string) and a number-based type
		(such as int)."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {65, new Dictionary<string, string>() {
        {"q", @"Best practice true or false:
			Prefer the `is` and `as` keyword to avoid throwing exceptions when casting between
			derived types. If you don't to this, you must write try-catch'es for InvalidCastException."},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {66, new Dictionary<string, string>() {
        {"q", @"True or false:
			In C#, unlike ordinary methods, constructors are not inherited, so we must explicitly
			declare and explicitly call the `base` constructor implementations."},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {67, new Dictionary<string, string>() {
        {"q", @"Explain:
			a) integration testing
			b) load testing"},
        {"a", @"a) Integration tests:
				Exercises two or more software components' ability to function together, also
				known as their ""integration"". May also include infrastructure concerns.
		b) Load tests:
				Aims to determine whether or not a system can handle a specified load. E.g. 
				the number of concurrent users using an application and the apps ability to handle
				interactions responsively."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {68, new Dictionary<string, string>() {
        {"q", @"In the context of unit testing, what is the difference between a:
			a) Fake
			b) Mock
			c) Stub"},
        {"a", @"a) Fake:
				A generic term that can be used to describe either a stub or a mock object.
		b) Mock:
				A fake object in the system that decides whether or not a unit test has passed
				  or failed. A mock is a fake until it's asserted against
		c) Stub:
				A controllable replacement for an existing dependency in the system. By using
				a stub, you can test your code without dealing with the dependency directly."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {69, new Dictionary<string, string>() {
        {"q", @"Microsoft has applied the `sealed` keyword to multiple classes, including System.String. This means
		that we will be unable to inherit from and extend System.String. Name the alternative language
		feature we can use to add new methods to strings."},
        {"a", @"Extension methods"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {70, new Dictionary<string, string>() {
        {"q", @"Consider the following snippet:
			public class StringExtensions
			{
				public static bool IsValidEmail(string input)
				{
					return Regex.IsMatch(input, @""[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+"");
				}
			}

		How would I modify the snippet to turn it into an extension method or the `string` type?"},
        {"a", @"Modification:
			public static class StringExtensions // 1) add `static` here
			{
				public static bool IsValidEmail(this string input) // 2) add `this` to the parameter type
				{
					return Regex.IsMatch(input, @""[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+"");
				}
			}"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {71, new Dictionary<string, string>() {
        {"q", @"What is the <AnalysisLevel> tag in the .csproj file used for?"},
        {"a", @"Controls the level of warnings introduced in each .NET version.

		E.g. <AnalysisLevel>6.0</AnalysisLevel> enables warnings introduced in .NET version
		up to and including 6.0."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {72, new Dictionary<string, string>() {
        {"q", @"Which command can you use in the terminal to check the versions of .NET SDKs and runtimes
		that you have installed and to warn you if any need updating?"},
        {"a", @"dotnet sdk check"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {73, new Dictionary<string, string>() {
        {"q", @"True or false:

			A single assembly can contain many namespaces and a namespace can be defined in
			many assemblies."},
        {"a", @"True"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {74, new Dictionary<string, string>() {
        {"q", @"What is the relationship between frameworks and packages?"},
        {"a", @"Packages define APIs, while frameworks group packages."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {75, new Dictionary<string, string>() {
        {"q", @"Consider `string` vs. `String` - which should you prefer and why?"},
        {"a", @"You should prefer lowercase `string` since it is a keyword and thus doesn't need
		the namespace (in this case 'System') to be imported. Unlike `String` which is an
		alias for System.String"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {76, new Dictionary<string, string>() {
        {"q", @"a) What are native-sized integers?
		b) Give a few examples of native-sized integers in C#?"},
        {"a", @"a) Native-sized integers are integer types for whose storage size for the value is platform specific.
		b) `nint`, `nuint`"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {77, new Dictionary<string, string>() {
        {"q", @"There are three ways to publish and deploy a .NET application, what are they?"},
        {"a", @"1) Framework-dependent deployment (FDD)
		2) Framework-dependent executable (FDE)
		3) Self-contained"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {78, new Dictionary<string, string>() {
        {"q", @"Which elements would you use in a .csproj file to specify that the output can run on linux and/or
		macOS and/or Windows OS?"},
        {"a", @"1) <RuntimeIdentifier> - for specifying a single OS to run on
		2) <RuntimeIdentifiers> - for specifying multiple OSs to run on"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {79, new Dictionary<string, string>() {
        {"q", @"Consider C++'s std::vector<T>::reserve, whose purpose is to allocate a pre-defined amount
		of memory ahead of assignment. What is the C# equivalent to this?"},
        {"a", @"The C# equivalent is `EnsureCapacity`"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {80, new Dictionary<string, string>() {
        {"q", @"When should you favour a C# array (such as double[]) over a C# collection (e.g. List<double>)?"},
        {"a", @"You should favour arrays over collections when the underlying data will not change size after
		instantiation."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {81, new Dictionary<string, string>() {
        {"q", @"Fill in the blank:

			If you need to work with a subset of an array, use a ____ because it is like a window
			into the original array. This is more efficient in terms of memory usage and improves
			performance. ___s only work with arrays, not collections, because the memory must be 
			contiguous."},
        {"a", @"Blank: span"},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {82, new Dictionary<string, string>() {
        {"q", @"Consider the following function signatures

			void ProcessCollection<T>(IEnumerable<T> collection); (A)
			void ProcessCollection<T>(List<T> collection);        (B)

		i) Which should you prefer?
		ii) Explain your choice in (i)"},
        {"a", @"i) (B)
		ii) IEnumerable<T> must allocate an object on the heap. When looping through `collection`
			both types will use the .Enumerator.GetEnumerator() method, which returns a stack-allocated
			struct for List<T> and a heap-allocated reference for IEnumerable<T>."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {83, new Dictionary<string, string>() {
        {"q", @"When and why should you use the `SecureString` type?"},
        {"a", @"When you require encryption of the text and assurance that the allocated memory for the text
		is release immediately. Concrete case would be for passwords."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {84, new Dictionary<string, string>() {
        {"q", @"When is it appropriate to use a `StringBuilder` class?"},
        {"a", @"When concatenating more than about three `string` variables, you'll be using less
		memory and will be getting improved performance using `StringBuilder` than using
		string.Concat method or the + operator."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {85, new Dictionary<string, string>() {
        {"q", @"What does it mean for a type to be 'anonymous'?"},
        {"a", @"An 'anonymous' type is one where the compiler generates a class for them
		with the relevant properties etc, but the type's name is known only to the compiler."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
    {86, new Dictionary<string, string>() {
        {"q", @"What does Action<T> encapsulate?"},
        {"a", @"Action<T> encapsulates a method that has a single parameter and does not return
		a value."},
        {"snippetQ", @""},
        {"snippetA", @""},
    }},
};
    }
}
